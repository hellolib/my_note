> **设计模式**是软件设计中常见问题的典型解决方案，是无数先驱和前辈总结的编码设计经验。

## 设计模式特征

- 设计模式与方法或库的使用方式不同，你很难直接在自己的程序中套用某个设计模式。模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案。

- 设计模式和算法的区别
  - 算法更像是菜谱：提供达成目标的明确步骤。
  - 模式更像是蓝图：你可以看到最终的结果和模式的功能，但需要自己确定实现步骤。

- 设计模式分类：
  - **创建型模式**：提供创建对象的机制，增加已有代码的灵活性和可复用性。 
  - **结构型模式**：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。
  - **行为模式**：负责对象间的高效沟通和职责委派。

- 设计模式的作用：
  - 设计模式是针对软件设计中常见问题的工具箱，其中的工具就是各种**经过实践验证的解决方案**。
  - 设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。

## 软件设计原则- SOLID原则

- *SOLID* 是让软件设计更易于理解、更加灵活和更易于维护的五个原则的简称。

### 1. S 单一职责原则

> **Single Responsibility Principle**  一个方法只完成一件事

- 尽量让每个类只负责软件中的一个功能，并将该功能完全封装（你也可称之为隐藏）在该类中。

- 这条原则的主要目的是减少复杂度。你不需要费尽心机地去构思如何仅用 200 行代码来实现复杂设计，实际上完全可以使用十几个清晰的方法。

- demo

  - 修改前：

    ![image-20221114172257478](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221114172257.png)

  - 修改后：

    ![image-20221114172314866](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221114172314.png)

### 2. O 开闭原则

> pen/Closesd Principle 对扩展开发，对修改关闭（常见做法：多态、基于接口实现、依赖注入）。

- 本原则的主要理念是在实现新功能时能保持已有代码不变。

- 如果你可以对一个类进行扩展， 可以创建它的子类并对其做 任何事情（如新增方法或成员变量、 重写基类行为等）， 那 么它就是开放的。 有些编程语言允许你通过特殊关键字（例 如 final ） 来限制对于类的进一步扩展， 这样类就不再是 “开放”的了。 如果某个类已做好了充分的准备并可供其他 类使用的话（即其接口已明确定义且以后不会修改）， 那么该类就是封闭（你可以称之为完整）的。

- demo

  - 你的电子商务程序中包含一个计算运输费用的 订单 Order 类， 该类中所有运输方法都以硬编码的方式实现。 如果你需 要添加一个新的运输方式， 那就必须承担对 订单 类造成破 坏的可能风险来对其进行修改。

    ![image-20221115150929996](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115150930.png)

  - 可以通过应用策略模式来解决这个问题。 首先将运输方法 抽取到拥有同样接口的不同类中。

    ![image-20221115151023036](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151023.png)

### 3. L 里氏替换原则

> Liskov Substitution Principle  子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

- 替换原则是用于预测子类是否与代码兼容， 以及是否能与其 超类对象协作的一组检查。 这一概念在开发程序库和框架时 非常重要， 因为其中的类将会在他人的代码中使用——你是 无法直接访问和修改这些代码的。
- 替换原则要求：
  1. 子类方法的参数类型必须与其超类的参数类型相匹配或更加 抽象。
  2. 子类方法的返回值类型必须与超类方法的返回值类型或是其 子类别相匹配。
  3. 子类中的方法不应抛出基础方法预期之外的异常类型。
  4. 子类不应该加强其前置条件。
  5. 子类不能削弱其后置条件。
  6. 子类不能修改超类中私有成员变量的值。



### 4. I 接口隔离原则

> Interface Segregation Principle 客户端不应被强迫依赖于其不使用的方法。
>

- 根据接口隔离原则， 你必须将“臃肿”的方法拆分为多个颗 粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。 否则， 对于“臃肿”接口的修改可能会导致程序出错， 即使 客户端根本没有使用修改后的方法。

- 继承只允许类拥有一个超类， 但是它并不限制类可同时实现 的接口的数量。 因此， 你不需要将大量无关的类塞进单个接 口。 你可将其拆分为更精细的接口， 如有需要可在单个类中 实现所有接口， 某些类也可只实现其中的一个接口。

- demo：

  ![image-20221115151731175](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151731.png)

  ![image-20221115151751487](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151751.png)

### 5. D 依赖倒置原则

> Dependency Inversion Principle 高层次的类不应该依赖于低层次的类。 两者都应该依 赖于抽象接口。 抽象接口不应依赖于具体实现。 具体 实现应该依赖于抽象接口。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

- 低层次的类实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。
- 高层次类包含复杂业务逻辑以指导低层次类执行特定操作。

- demo

  ![](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115152548.png)

  ![image-20221115152602170](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115152602.png)

## 设计模式分类

### 1. 创建型模式

1. 工厂方法
2. 抽象工厂
3. 生成器
4. 原型
5. 单例

### 2. 结构型模式

1. 适配器
2. 桥接
3. 组合
4. 装饰
5. 外观
6. 亨元
7. 代理

### 3. 行为型模式

1. 责任链
2. 命令模式
3. 迭代器
4. 中介者
5. 备忘录
6. 观察者
7. 状态
8. 策略
9. 模板方法
10. 访问者