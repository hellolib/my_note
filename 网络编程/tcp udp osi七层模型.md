## 1.协议

![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220702151927.jpg)

### 1.1 TCP协议

> TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
>
> - **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
> - **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
> - **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。
>
> 什么是 TCP 连接？
>
> - 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。
>
> TCP 四元组可以唯一的确定一个连接，四元组包括如下.
>
> - 源地址
> - 源端口
> - 目的地址
> - 目的端口

- 可靠,速度慢,全双工通信

- 建立连接**三次握手**,断开连接**四次挥手**

- 建立起链接之后,发送每条消息都有回执,为了保证数据的完整性,还有重传机制

- 数据传输:有收必有发,收发必相等

- 长连接:会一直占用对方端口

- IO操作(input/output),IO操作的输入输出时相对内存来说
  - write-send (输出ouput)
  - read-recv (输入input)
  
  ```python
  #三次握手
  TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1] 
  TCP三次握手的过程如下：
  客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
  服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。
  客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。
  三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。
                          
  #四次挥手
  (1) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。
  (2) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。
  注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。
  (3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。
  (4) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。[1] 
  既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。
                          
  
  ```
  

![image-20211014215735168](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/image-20211014215735168.png)

> - HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
>
> - TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

### 1.2 UDP协议

- 不需要建立连接,速度特别快,可能会丢消息.

### 小结(TCP/UDP重点)

- tcp/udp 的区别

  ```sh
  #1. 连接
  
  TCP 是面向连接的传输层协议，传输数据前先要建立连接。
  UDP 是不需要连接，即刻传输数据。
  #2. 服务对象
  
  TCP 是一对一的两点服务，即一条连接只有两个端点。
  UDP 支持一对一、一对多、多对多的交互通信
  #3. 可靠性
  
  TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
  UDP 是尽最大努力交付，不保证可靠交付数据。
  #4. 拥塞控制、流量控制
  
  TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
  UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
  #5. 首部开销
  
  TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
  UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
  #6. 传输方式
  
  TCP 是流式传输，没有边界，但保证顺序和可靠。
  UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
  #7. 分片不同
  
  TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
  UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。
  ```

  

- 应用场景
  - TCP:文件上传下载(邮件,网盘)
  - UDP:即时通讯(微信,qq)

- 传输文件长度:
  - TCP 长度无限
  - UDP 能够传输的数据航都是有限的,根据数据传递设备的设置有关系

## 2.osi七层模型

- '应表会传网数物'

  ```也叫osi五层模型,专业七层,开发人员掌握五层模型,表示层会话层了解```

  - **应用层**:python代码
  - 表示层
  - 会话层
  - **传输层**:tcp协议 udp协议 端口
  - **网络层**:ipv4/ipv6协议
  - **数据链路层**:mac地址 arp协议
  - **物理层**:

​		![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220702151646)

### 每层运行常见协议/物理设备

| tcp/ip五层  | 每层运行常见协议                | 每层运行常见物理设备   |
| ----------- | ------------------------------- | ---------------------- |
| 5应用层     | python代码/http/https/ftp/smtp/ |                        |
| 4传输层     | tcp/udp协议 端口                | 四层交换机/四层路由器  |
| 3网络层     | ipv4/ipv6协议                   | 三层路由器/三层交换机  |
| 2数据链路层 | mac地址/arp协议                 | 网卡/交换机/二层交换机 |
| 1物理层     |                                 |                        |

## 3.socket

- 中文名字:套接字

- **Socket是应用层与传输层中间的抽象层，Socket帮助去组织拼接信息数据，以符合指定的协议。**

- socket对于程序员来说,已经是网络操作的底层了                                     

  ![image-20211024173450199](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/image-20211024173450199.png)



## 4. http协议

- 超文本传输协议（英文：Hyper Text Transfer Protocol，HTTP）是一种用于分布式、协作式和超媒体信息系统的**应用层协议**,双工通信。
- HTTP是一个客户端终端（用户）和服务器端（网站）**请求和应答**的标准（TCP）;**即规定发送与接受的数据格式;**
- 默认端口为80;

### 4.1 HTTP协议工作原理

<https://www.cnblogs.com/maple-shaw/articles/9060408.html>

- HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

- http适用tcp协议通信

  ```python
  #在浏览器地址栏键入URL,按下回车之后会经历以下流程:(面试)
  
  1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
  2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
  3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
  4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
  5.释放(断开) TCP连接;
  6.浏览器将该 html 文本并显示内容; 
  ```

### 2.2 HTTP请求方法

- **八种方法(get/post是重点 head put delete options trace connect)**
- **get 获取数据;向指定的资源发出“显示”请求。** *使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问*。
- **post 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。** *数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有*。

### 4.3 http状态码

- *所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。*

- 状态代码的第一个数字代表当前响应的类型：
  - **1xx消息**——请求已被服务器接收，继续处理
  - **2xx成功**——请求已成功被服务器接收、理解、并接受
  - **3xx重定向**——需要后续操作才能完成这一请求
  - **4xx请求错误**——请求含有词法错误或者无法被执行404(资源不存在)403(权限不够)402
  - *5xx服务器错误——服务器在处理某个正确请求时发生错误*500服务器内部错误

### 4.4 URL

- 超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：
  - **传送协议。**
  - 层级URL标记符号(为[//],固定不变)
  - 访问资源需要的凭证信息（可省略）
  - **服务器**。（通常为域名，有时为IP地址）
  - **端口号**。（以数字方式表示，若为HTTP的默认值“:80”,https默认端口(443)可省略）
  - **路径**。（以“/”字符区别路径中的每一个目录名称）
  - **查询**。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）
  - 片段.锚点。以“#”字符为起点

### 4.5 HTTP请求与响应格式(重点)

- http请求格式(request请求,浏览器给服务器发送的消息)
  - get请求没有请求数据
  - ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/867021-20180330221943115-1291906159.png)
- http响应格式(response 响应,服务器返回给浏览器的信息)
  - ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/867021-20180330222031912-1851965755.png)

## 5. Ping工作流程

### 0. ICMP 

- 全称是 **Internet Control Message Protocol**，也就是**互联网控制报文协议**。里面有个关键词 —— **控制**，如何控制的呢？
  - 网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。

- `ICMP` 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**



> **以下面一个网络为例：有A、B、C、D四台机子，一台路由RA，子网掩码均为 255.255.255.0，默认路由为 192.168.0.1 [1]**

### 1. 在同一网段内 

- 在主机A上运行“Ping 192.168.0.5”后，都发生了些什么呢? 
  1. 首先，Ping命令会构建一个固定格式的`ICMP`请求数据包，然后
  2. 由ICMP协议将这个数据包连同地址“192.168.0.5”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程）
  3. IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并想办法得到192.168.0.5的MAC地址(arp协议)（物理地址，这是数据链路层协议构建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就在这里，IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络内查找这台机器的MAC,如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC,一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。 主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。 

### 2. 不在同一网段内 

- 在主机A上运行“Ping 192.168.1.4”后，开始跟上面一样，到了怎样得到MAC地址时，IP协议通过计算发现D机与自己不在同一网段内，就直接将**交由路由处理**，也就是将路由的MAC取过来，至于怎样得到路由的MAC，跟上面一样，先在ARP缓存表找，找不到就广播吧。路由得到这个数据帧后，再跟主机D进行联系，如果找不到，就向主机A返回一个超时的信息。
