## 计算机存储

- 存储方式：数据都是 以2进制来做存储
- 存储单位：我们以字节为基本单位存储在计算机中（位-->8位-->1字节 -->1024字节-->1kb-->1024kb-->1m--->2014m--->1t）

## 为什么 0.1+0.2!=0.3 

- 在Go语言中，浮点数的计算不准确是由于其内部实现采用了IEEE 754标准，这种标准使用二进制的科学计数法来表示实数。由于二进制的科学计数法无法精确地表示所有实数，因此在转换为浮点数时会出现精度损失的情况。

- 代码（float64）：

  ```go
  func main() {
  	var m1 float64 = 0.1
  	var m2 float64 = 0.2
  	fmt.Println(m1 + m2)  // 输出：0.30000000000000004
  }
  ```

- **原因：**

  > https://xiaolincoding.com/os/1_hardware/float.html

  - 0.1 这个十进制小数在二进制中是一个无限循环小数，无法用有限的二进制位数来表示。
  - Go语言会将其转换成最接近的二进制表示。在转换成二进制的过程中，若二进制位数不足，则采用四舍五入的方式取舍，其中0.1 在float64 情况下大约为`0.000110011001100110011001100110011001100110011001100110011001101`,这个二进制数在转换成十进制时，近似等于`0.1000000000000000055511151231257827021181583404541015625`，与0.1略有偏差
  - 所以就造成了浮点数计算最终的精度丢失

- 代码（float32）

  ```go
  func main() {
  	var m1 float32 = 0.1
  	var m2 float32 = 0.2
  	fmt.Println(m1 + m2)  // 输出：0.3
  }
  ```

- 为什么又相等了呢？

  - float32类型的变量在存储时只使用了32位二进制位数，因此精度相对较低，可以表示的数值范围和精度都有一定的限制。当使用float32类型的变量进行比较时，Go语言会对两个浮点数的差值进行比较，如果差值小于一定的阈值，就认为这两个浮点数相等。
  - 当使用float32类型的变量进行比较时，Go语言会对两个浮点数的差值进行比较，如果差值小于一定的阈值，就认为这两个浮点数相等。这个阈值通常被称为“机器精度”（machine epsilon），可以通过math包中的float32和float64常量来获取。
  - 使用float32类型的变量进行比较时，由于float32类型的存储精度较低，精度误差也就较小，因此在一定范围内的比较结果通常是准确的。

## 解决办法（decimal）

>  利用第三方库解决浮点数计算精度丢失问题: https://github.com/shopspring/decimal

1. 浮点数加减运算

   ```go
   package main
   
   import (
   	"fmt"
   	"github.com/shopspring/decimal"
   )
   
   func main() {
   
   	// a = 2.3329 b = 3.1234
   	a, b := 2.3329, 3.1234
   
   	c := decimal.NewFromFloat(a)
   	d := decimal.NewFromFloat(b)
   	fmt.Println(a, b)
   	fmt.Println(c, d)
   	fmt.Println("此时ab 与 cd 相同")
   	
   	fmt.Println(a + b)    //5.456300000000001}
   	fmt.Println(c.Add(d)) //5.4563}
   
   }
   ```

   

2. float64与float32之间转换

   ```go
   package main
   
   import (
   	"fmt"
   	"github.com/shopspring/decimal"
   )
   
   func main() {
   
   	var a float32
   	a = 9.99999
   	c := decimal.NewFromFloat32(a)
   	
   	b := float64(a)
   	c.Float64()
   	fmt.Println(b) //9.999990463256836}
   	fmt.Println(c.Float64()) //9.99999}
   
   }
   ```

   

3. float64位直接乘100

   ```go
   package main
   
   import (
   	"fmt"
   	"github.com/shopspring/decimal"
   )
   
   func main() {
   
   	var a float64
   	a = 1128.61
   	c := decimal.NewFromFloat(a)
   
   	b := a * 100
   	fmt.Println(b) //112860.99999999999}
   	fmt.Println(c.Mul(decimal.NewFromInt(100))) //112861}
   
   }
   ```

   