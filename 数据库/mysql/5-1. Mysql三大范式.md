> 设计出合理的关系型数据库，需要满足一定的规范，通常所说的三范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）。

#### 第一范式

确保每列保持原子性，每列不可分。

举例：

| id   | stu_name | stu_age | stu_con         |
| :--- | :------- | :------ | :-------------- |
| 1    | tom      | 13      | 济南153****0531 |

单独通过手机号无法查询到学生信息，可以把stu_con拆分为地址与联系电话。

| id   | stu_name | stu_age | stu_addr | stu_con     |
| :--- | :------- | :------ | :------- | :---------- |
| 1    | tom      | 13      | 济南     | 153****0531 |

#### 第二范式

前提满足第一范式，非主属性完全依赖于主关键，而不是仅仅依赖主键的部分。（联合主键）

举例：

| stu_id | course_id | stu_name | stu_age | course_name | score |
| :----- | :-------- | :------- | :------ | :---------- | :---- |
| JS9101 | 101       | tom      | 12      | 语文        | 100   |

此表满足第一范式，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

用通俗的说法表达就是**每一张表只描述一件事**。

`学生表`：

| stu_id | stu_name | stu_age |
| :----- | :------- | :------ |
| 1      | tom      | 13      |

`课程表`:

| coures_id | course_name |
| :-------- | :---------- |
| 101       | 语文        |

`课程成绩表`:

| stu_id | course_id | score |
| :----- | :-------- | :---- |
| 1      | 101       | 100   |

#### 第三范式

前提满足第一范式与第二范式,属性不依赖于其他非主属性,每一列必须与主键直接相关，而不是间接相关。

举例：

`学生表`:

| stu_id | stu_name | stu_age | class  | class_num |
| :----- | :------- | :------ | :----- | :-------- |
| 1      | tom      | 13      | 六年级 | 2班       |

class_num与class直接相关，class与stu_id直接相关，class_num与stu_id间接相关，违背第三范式。

> 修改的话，把班级相关内容单独建表。



- 虽然有三范式的规则在，但是在生产环境中，有些项目为了追求查询速度、提高性能等还会不采用规则。