## Redis 常见数据类型

- 3.0版本之前数据结构

  |    数据类型     |    底层数据结构     |
  | :-------------: | :-----------------: |
  | String(字符串)  |   SDS 动态字符串    |
  |   List(列表)    | 压缩列表 + 双端链表 |
  | Set(集合-无序)  |       hash表        |
  | ZSet(集合-有序) |  压缩列表 + 跳跃表  |
  | Hash(哈希类型)  |  hash表 + 压缩列表  |
  
- 3.0版本之后数据结构

  |    数据类型     |   底层数据结构    |
  | :-------------: | :---------------: |
  | String(字符串)  |  SDS 动态字符串   |
  |   List(列表)    |     quicklist     |
  | Set(集合-无序)  |      hash表       |
  | ZSet(集合-有序) | listpack + 跳跃表 |
  | Hash(哈希类型)  | hash表 +listpack  |
  

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704153014.png)

 

## Redis 键值对数据库实现原理

- Redis 的键值对中的 key 就是字符串对象，而 **value 可以是字符串对象，也可以是集合数据类型的对象**，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。

- demo

  ```redis
  > SET name "xiaolincoding"
  OK
  > HSET person name "xiaolincoding" age 18
  0
  > RPUSH stu "xiaolin" "xiaomei"
  (integer) 4
  
  ```

  - 第一条命令：name 是一个**字符串键**，因为键的**值是一个字符串对象**；
  - 第二条命令：person 是一个**哈希表键**，因为键的**值是一个包含两个键值对的哈希表对象**；
  - 第三条命令：stu 是一个**列表键**，因为键的**值是一个包含两个元素的列表对象**；

- Redis 是使用了一个「哈希表」保存所有键值对(这个hash表的负载因子是1)，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

  > - 负载因子 = 键数量/bucket数量
  > - 哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：
  >   - 哈希因子过小，说明空间利用率低
  >
  >   - 哈希因子过大，说明冲突严重，存取效率低
  > - 每个哈希表的实现对负载因子容忍程度不同，Redis实现中负载因子大于1时就会触发rehash，**而Go则在在负载因子达到6.5时才会触发rehash**，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。

- 哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704151940.png)

## Redis 底层数据结构

### 1. SDS 动态字符串

- C 语言的字符串的缺陷

  - C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符
  - C 语言获取字符串长度的时间复杂度是 O(N), 就是获取字符串长度的时候需要遍历字符串
  - 字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；
  - 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；

- SDS数据结构

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704152406.png)

  - **len，记录了字符串长度**。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
  - **alloc，分配给字符数组的空间长度**。这样在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
  - **flags，用来表示不同类型的 SDS**。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。
  - **buf[]，字符数组，用来保存实际数据**。不仅可以保存字符串，也可以保存二进制数据。

### 2. 链表

- **数据结构**

  - Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便

    ```c
    typedef struct list {
        //链表头节点
        listNode *head;
        //链表尾节点
        listNode *tail;
        //节点值复制函数
        void *(*dup)(void *ptr);
        //节点值释放函数
        void (*free)(void *ptr);
        //节点值比较函数
        int (*match)(void *ptr, void *key);
        //链表节点数量
        unsigned long len;
    } list;
    ```

    

- **优缺点**
  - 优点
    1. listNode 链表节点的结构里带有 prev 和 next 指针，**获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表**；
    2. list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；
    3. list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；
    4. listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此**链表节点可以保存各种不同类型的值**；
  - 缺点
    1. 表每个节点之间的内存都是不连续的，意味着**无法很好利用 CPU 缓存**。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。
    2. 还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，**内存开销较大**。

### 3. 压缩列表

> 压缩列表是 Redis 为了节约内存而开发的，它是**由连续内存块组成的顺序型数据结构**，有点类似于数组。

- **数据结构**

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154010.png)

  - ***zlbytes***，记录整个压缩列表占用对内存字节数；
  - ***zltail***，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
  - ***zllen***，记录压缩列表包含的节点数量；
  - ***zlend***，标记压缩列表的结束点，固定值 0xFF（十进制255）

- **优缺点**

  - 优点: 压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。
  - 缺点: 
    1. 不能保存过多的元素，否则查询效率就会降低；
    2. 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。
    3. **虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题**。**压缩列表只会用于保存的节点数量不多的场景**，只要节点数量足够小，即使发生连锁更新，也是能接受的。

### 4. 哈希表

- **数据结构**

  ```c
  typedef struct dictht {
      //哈希表数组
      dictEntry **table;
      //哈希表大小
      unsigned long size;  
      //哈希表大小掩码，用于计算索引值
      unsigned long sizemask;
      //该哈希表已有的节点数量
      unsigned long used;
  } dictht;
  ```

  - 可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。

    ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154304.png)

- rehash**流程**

  > - **当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。**
  > - **当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。**

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154450.png)



### 5. 整数集合

> 整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。

- **数据结构**

  ```c
  typedef struct intset {
      //编码方式
      uint32_t encoding;
      //集合包含的元素数量
      uint32_t length;
      //保存元素的数组
      int8_t contents[];
  } intset;
  ```

### 6. 跳表 !!!

> - Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。
>
> - Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。
>
>   ```c
>   typedef struct zset {
>       dict *dict;
>       zskiplist *zsl;
>   } zset;
>   ```
>
> - Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。

#### 6.1  数据结构

- 跳跃表数据结构

  ```c
  typedef struct zskiplist {
      struct zskiplistNode *header, *tail;
      unsigned long length;
      int level;
  } zskiplist;
  ```

  - 跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；
  - 跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；
  - 跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；

- 链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。**跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表**，这样的好处是能快读定位数据。

- 一个层级为 3 的跳表

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704155310.png)

- 图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：

  - L0 层级共有 5 个节点，分别是节点1、2、3、4、5；
  - L1 层级共有 3 个节点，分别是节点 2、3、5；
  - L2 层级只有 1 个节点，也就是节点 3 。

- 如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。

- 可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。

#### 6.2 跳跃表的查询

- 查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：

  - 如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。
  - 如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。

- 如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。举个例子，下图有个 3 层级的跳表。

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704160119.png)

- 如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：

  - 先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；

  - 但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];

  - 「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；

  - 「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。

### 7. quicklist

> - 其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。
> - 压缩列表有问题, quicklist 解决办法，**通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。**

- **数据结构**

  - quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。

  ```c
  typedef struct quicklist {
      //quicklist的链表头
      quicklistNode *head;      //quicklist的链表头
      //quicklist的链表头
      quicklistNode *tail; 
      //所有压缩列表中的总元素个数
      unsigned long count;
      //quicklistNodes的个数
      unsigned long len;       
      ...
  } quicklist;
  ```

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704160559.png)



### 8. listpack

- quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。
- 因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。
- 于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。