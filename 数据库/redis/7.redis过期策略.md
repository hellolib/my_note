

## 定期删除和惰性删除

- 我们Redis设置了过期时间，其实内部是 定期删除 + 惰性删除两个再起作用的。

- 所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。

- 但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。

- 并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下

- 通过上述两种手段结合起来，保证过期的key一定会被干掉。

- 很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。

- 但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？

> 答案是：走内存淘汰机制。

## redis数据淘汰策略

1. **noeviction**(不淘汰)：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了
2. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
3. **allkeys-random**：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊
4. **volatile-lru**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
5. **volatile-random**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
6. **volatile-ttl**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

## LRU 和 LFU

*详细参考我的博客: https://bigox.top/*

> LRU和LFU都是内存管理的页面置换算法。
>
> LRU：最近最少使用(最长时间)淘汰算法（Least Recently Used）。LRU是淘汰最长时间没有被使用的页面。
>
> LFU：最不经常使用(最少次)淘汰算法（Least Frequently Used）。LFU是淘汰一段时间内，使用次数最少的页面。

- 例子

  > 假设LFU方法的时期T为10分钟，访问如下页面所花的时间正好为10分钟，内存块大小为3。若所需页面顺序依次如下：
  >
  > 2  1  2  1  2  3  4 
  >
  > ---------------------------------------->

  - 当需要使用页面4时，内存块中存储着1、2、3，内存块中没有页面4，就会发生缺页中断，而且此时内存块已满，需要进行页面置换。
  - 若按LRU算法，应替换掉页面1。因为页面1是最长时间没有被使用的了，页面2和3都在它后面被使用过。
  - 若按LFU算法，应换页面3。因为在这段时间内，页面1被访问了2次，页面2被访问了3次，而页面3只被访问了1次，一段时间内被访问的次数最少。

  > **LRU 关键是看页面最后一次被使用到发生替换的时间长短，时间越长，页面就会被置换；** 
  >
  > **LFU关键是看一定时间段内页面被使用的频率（次数），使用频率越低，页面就会被置换。**

- LRU算法适合：较大的文件比如游戏客户端（最近加载的地图文件）;

- LFU算法适合：较小的文件和零碎的文件比如系统文件、应用程序文件 ;

- LRU消耗CPU资源较少，LFU消耗CPU资源较多。
