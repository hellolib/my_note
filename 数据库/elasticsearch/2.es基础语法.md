> 参考: https://blog.csdn.net/LONG_Yi_1994/article/details/123939544

## IK分词器

> - 类似python中的`jieba`分词
>
> - 两种分词模式
>   1. ik_smart
>   2. ik_max_word

- 不同分词效果

  1. **ik_smart**: 为最少切分, 就是尽可能少的切分;

     ```sh
     GET _analyze
     {
       "analyzer": "ik_smart",
       "text": "go语言开发者"
     }
     
     go 语言  开发者 
     ```

  2. **ik_max_word**: 为最细粒度划分, 穷尽词库的可能;

     ```sh
     GET _analyze
     {
       "analyzer": "ik_max_word",
       "text": "go语言开发者"
     }
     
     go 语言 开发 开发者 者
     ```

     

- 和`jieba`分词可以配置用户字典: 配置文件路径在ik/config/IKAnalyzer.cfg.xml  * 可以新建一个kuang.dic文件, 然后在IKAnalyzer.cfg.xml中添加配置    - ```<entry key="ext_dict">kuang.dic</entry>```    - ```<entry key="ext_stopwords">kuang_stop.dic</entry>```

## 数据类型

- 字符串类型: text和keyword
  - 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）、**keyword类型只能整体搜索，不支持搜索部分内容**

- 数值类型: long, integer, short, byte, double, float, half float, scaled float
- 日期类型: date
- te布尔值类型: boolean
- 二进制类型: binary
- 对象：object

> 指定字段类型: 添加一个库并添加字段规则(类似mysql建表)

```apl
PUT /test2
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "age": {
        "type": "long"
      },
      "birthday": {
        "type": "date"
      }
    }
  }
}
# 返回结果发现acknowledged是true, 说明规则创建成功
```

## 映射

- 映射类似与MySQL中的表设计，包括约束指定字段的类型(text、keyword等)。text类型的字段支持分词，keyword类型的字段不支持分词、必须完全匹配。

- keyword类型的字段才支持聚合查询(例如：分组)

- 常见mapping属性

  - type：字段数据类型
  - index：是否创建索引，默认为true
  - analyzer：使用哪种分词器
  - properties：该字段的子字段

- 通过type指定字段类型，通过index指定该字段是否可以被索引查询，当index为false时，将无法通过该字段进行查询。

  ```apl
  GET /user/_mapping
  
  {
      "properties":{
          "name":{
              "type": "text",
              "index": true
          },
          "sex":{
              "type": "text",
              "index": true
          },
          "tel":{
              "type": "text",
              "index": true
          },
          "province":{
              "type":"keyword",
              "index":"true"
          }                
      }
  }
  ```

### 1. 创建mapping

- 方法1

  ```apl
  PUT 索引名
  {
    "mappings": {
      "properties": { 
        "foo": {
          "type": "keyword"
        }
      }
    }
  }
  ```

- 方法2

  ```apl
  PUT 索引名/_mappings
  {
    "properties": { 
      "bar": {
        "type": "text"
      }
    }
  }
  ```

### 2. 查询mapping

```apl
GET 索引名/_mappings
```



## 分片

- 分片类似MySQL中的分表，创建索引时，默认3个分片，这个分片数量是可以修改的。

  ```apl
  PUT 索引名/_settings
  {
      "number_of_replicas":2
  }
  ```

  

## 基础操作

### 1. 索引库和映射操作

- 创建索引

  > **基本语法**：
  >
  > - 请求方式：GET
  > - 请求路径：/索引库名
  > - 请求参数：无

  ```bash
  PUT /索引库名称
  PUT /conan
  {
    "mappings": {
      "properties": {
        "column1":{
          "type": "text",
          "analyzer": "ik_smart"
        },
        "column2":{
          "type": "keyword",
          "index": "false"
        },
        "column3":{
          "properties": {
            "子字段1": {
              "type": "keyword"
            },
            "子字段2": {
              "type": "keyword"
            }
          }
        },
        // ...略
      }
    }
  }
  ```

- 查看索引信息

  > **基本语法**：
  >
  > - 请求方式：GET
  > - 请求路径：/索引库名
  > - 请求参数：无

  ```bash
  GET /索引库名
  ```

-  查看全部索引

  ```bash
  GET  _cat/indices?v
  ```
  
-  删除索引

  ```bash
  DELETE url/索引名
  ```

### 2. 文档操作

- 创建文档：POST /{索引库名}/_doc/文档id
- 查询文档：GET /{索引库名}/_doc/文档id
- 删除文档：DELETE /{索引库名}/_doc/文档id
- 修改文档：
  - 全量修改：PUT /{索引库名}/_doc/文档id
  - 增量修改：POST /{索引库名}/_update/文档id { "doc": {字段}}

#### 2.1 创建文档

- **创建文档(指定文档id)**

  >  PUT: 创建文档(指定文档id), localhost:9200/索引名称/类型名称/文档ID

  ```apl
  POST /索引库名/_doc/文档id
  {
      "字段1": "值1",
      "字段2": "值2",
      "字段3": {
          "子属性1": "值3",
          "子属性2": "值4"
      },
      // ...
  }
  demo 
  POST /heima/_doc/1
  {
      "info": "真相只有一个！",
      "email": "zy@itcast.cn",
      "name": {
          "firstName": "柯",
          "lastName": "南"
      }
  }
  ```

- **创建文档(随机文档id)**

  > POST: 创建文档(随机文档id), localhost:9200/索引名称/类型名称

  ```apl
  POST /test1/_doc
  {
    "name": "狂神说",
    "age": 3
  }
  ```

#### 2.3 查询文档

- **根据id查询**

  ```bash
  GET 索引名/_doc/文档id
 
  例： GET /i_user/_doc/1
  ```

- **查询全部**

  ```bash
  GET 索引名/_search
   
  例：shopping/_search
  ```
  
- **查询全部**
  
  > 将参数放在请求体里
  
  ```bash
  GET 索引名/_search
  {
      "query":{ 
          "match_all":{ 
          	"name":"xxx" # 条件查询
          } 
      } 
  }
  ```

#### 2.4 更新文档

- 全量更新

  > （相当于先删除，后创建，只是id没变）

  ```bash
  POST/PUT 索引名/_doc/id

  参数放请求体 {}
  ```

- 部分更新：

  ```bash
  POST 索引名/_update/id
  {
      "doc": {参数}
  }
  
  例：
  POST  /shopping/_update/1056
  {
      "doc":{
         "title":"华为手机"
      }
  }
  ```

  

#### 2.5 删除文档

```bash
DELETE 索引名/_doc/id 

例： shopping/_doc/1056
```

### 3. 条件查询 + 分页

> - **查询所有**：查询出所有数据，*一般测试用*。例如：match_all、match；分词搜索，会把查询关键词先进行分词，然后进行搜索
> - **全文检索（full text）查询**：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：
>   - match_query
>   - multi_match_query
> - **精确查询**：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：
>   - ids
>   - range
>   - term
> - **地理（geo）查询**：根据经纬度查询。例如：
>   - geo_distance
>   - geo_bounding_box
> - **复合（compound）查询**：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：
>   - bool
>   - function_score

- 条件查询

  - ```apl
    GET 索引名/_search?q=key:value
     
    例：shopping/_search?q=title:华为
    ```

  - ```apl
    GET 索引名/_search   // 查询所有
    {
        "query":{ 
            "match_all":{ 
            	"name":"xxx" # 条件查询
            } 
        } 
    }
    ```

- 分页

  ```apl
  GET 索引名/_search
   
  参数：
  {
      "query":{
          "match_all":{
          }
      },
      "from": 2,
      "size": 2
  }
   
  from：表示第几条记录
  size：表示每页多少记录
   
  from=(页码-1)*size
  ```

### 4. 指定要查询的列

```apl
GET /索引名/_search
 
{
    "query":{
        "match_all":{
        }
    },
    "from": 2,
    "size": 2,
    "_source": ["title"]
}
 
# 通过 _source 指定只查询 title 字段
```

### 5. 排序

> 注意：如果排序时使用了分页查询，则是先排序，后分页。

```apl
GET /索引名/_search
 
{
    "query":{
        "match_all":{
        }
    },
    "from": 2,
    "size": 2,
    "_source": ["title","price"],
    "sort":{
        "price":{
            "order":"asc"
        }
    }
}
 
# sort表示要对查询结果进行排序
# price表示要排序的字段
# order指定排序方式，升序还是降序
```

### 6. 多条件查询

>  must (and)   ,    should (or)

```apl
GET 索引名/_search
 
例： 查询category为华为的所有文档 must理解为：并且、同时成立
GET shopping/_search
{
    "query":{
        "bool":{
            "must":[
              {
                "match":{
                    "category":"华为"
                }
              }
            ]
        }
    }    
}
 
例：查询category为华为并且price为3888的文档
GET shopping/_search
{
    "query":{
        "bool":{
            "must":[
              {
                "match":{
                    "category":"华为"
                }
              },
              {
                "match":{
                    "price":"3888"
                }
              }              
            ]
        }
    }
}
 
 
例：查询category为华为或OPPO的文档,并按price排序 should可以理解为：或
GET shopping/_search
{
    "query":{
        "bool":{
            "should":[
              {
                "match":{
                    "category":"华为"
                }
              },
              {
                "match":{
                    "category":"OPPO"
                }
              }
            ]
        }
    },
    "sort":{
        "price":{
            "order":"asc"
        }
    }  
}
 
 
例：查询 查询category为华为或小米或OPPO的手机，并且价格大于5000，此处使用filter，gt表示大于，lt表示小于。
GET shopping/_search
{
    "query":{
        "bool":{
            "should":[
              {
                "match":{
                    "category":"华为"
                }
              },
              {
                "match":{
                    "category":"小米"
                }
              },
              {
                "match":{
                    "category":"OPPO"
                }
              }                          
            ],
            "filter":{
                "range":{
                    "price":{
                        "gt":5000
                    }
                }
            }
        }
    }
}
 
```

### 7. 查询分类

- 全文查询（类似模糊搜索）

- 精准匹配

- 地理查询：https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html

  - 经纬度查询
  - 矩形查询
  - 附近查询

- 复合查询：

  - 复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。
  - fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名
  - bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索

   

#### 7.1 全文查询

- match和multi_match的区别是什么？
  - match：根据一个字段查询【推荐：使用copy_to构造all字段】
  - multi_match：根据多个字段查询，参与查询字段越多，查询性能越差

- match：分词搜索，会把查询关键词先进行分词，然后进行搜索

  ```apl
  例：下面的查询会把category含有小或含有华的都查出来
  GET /shoppting/_search
  {
      "query":{
          "match":{
              "category":"小华"
          }
      }
  }
  ```

- match_all：查询所有, 没有查询条件

  ```bash
  // 查询所有
  GET /indexName/_search
  {
    "query": {
      "match_all": {
      }
    }
  }
  
  ```
  
- match_phrase：精确查询（精准词组查询）

  ```apl
  GET /my_index/_search
  {
    "query": {
      "match_phrase": {
        "my_field": "精确词组"
      }
    }
  }  这个查询将返回包含"精确词组"的文档。请注意，匹配的词组必须以该顺序在字段中出现才能匹配成功。
  ```

#### 7.2 精准查询

- 精准查询类型：

  - term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段;**根据词条精确值查询**
  - range查询：根据数值范围查询，可以是数值、日期的范围;**根据值的范围查询**

- **term** 查询

  - 因为精确查询的字段搜时不分词的字段，因此查询的条件也必须是**不分词**的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。

  - demo

    ```sh
    GET /i_user/_search
    {
        "query":{ 
            "term":{ 
              "age":{
                "value": 18
              }
            } 
        } 
    }

- **range** 查询

  - 范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。

  - demo

    ```sh
    GET /i_user/_search
    {
      "query": {
        "range": {
          "age": {
            "gt": 18,
            "lte": 190
          }
        }
      }
    }
    ```

### 8. 聚合查询

> **aggregations**：聚合
>
> **significant**：重要

- 聚合必须的三要素：

  - 聚合名称
  - 聚合类型
  - 聚合字段

- 聚合可配置属性有：

  - size：指定聚合结果数量
  - order：指定聚合结果排序方式
  - field：指定聚合字段

- 聚合常见的有三类：

  - **桶（Bucket）**聚合：用来对文档做分组

    - TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组
    - Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组

  - **度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等

    - Avg：求平均值
    - Max：求最大值
    - Min：求最小值
    - Stats：同时求max、min、avg、sum等

  - **管道（pipeline）**聚合：其它聚合的结果为基础做聚合

    > 如：用桶聚合实现种类排序，然后使用度量聚合实现各个桶的最大值、最小值、平均值等

#### 8.1 分组查询

```apl
# 按price字段进行分组
GET /shopping/_search
{
    "aggs":{
        "category_group":{
            "terms":{
                "field": "price"
            }
        }
    }
}
 
# 默认会一并将所有文档信息也查出来，如果不需要查询文档信息，可以指定size为0
GET /shopping/_search
{
    "aggs":{
        "category_group":{
            "terms":{
                "field": "price"
            }
        }
    },
    "size": 0
}
```



#### 8.2 求平均数

```apl
#查询所有文档price的平均值
GET /shopping/_search
{
    "aggs":{
        "category_avg":{
            "avg":{
                "field": "price"
            }
        }
    }
}
 
#不查询文档详细信息
GET /shopping/_search
{
    "aggs":{
        "category_avg":{
            "avg":{
                "field": "price"
            }
        }
    },
    "size": 0
}
```



#### 8.3**桶（Bucket）**、度量(Metric) 、管道(pipeline)聚合

- 桶

  ```sh
  GET /hotel/_search
  {
    "query": { //限定要聚合的文档范围，只要添加query条件【一般在没搜索关键字时不写query】
      "range": {
        "price": {
          "lte": 200 // 只对200元以下的文档聚合
        }
      }
    }, 
    "size": 0,  // 设置size为0，结果中不包含查询结果文档，只包含聚合结果
    "aggs": { // 定义聚合
      "brandAgg": { //给聚合起个名字
        "terms": { // 聚合的类型，按照品牌值聚合，所以选择term
          "field": "brand", // 参与聚合的字段
          "order": {
            "doc_count": "asc" // 对聚合结果按照doc_count升序排列
          },
          "size": 20 // 希望获取的聚合结果数量【设置多少就最多只显示多少】
        }
      }
    }
  }
  
  ```

- 度量聚合很少单独使用，一般是和桶聚合一并结合使用

  ```sh
  GET /hotel/_search
  {
    "size": 0, 
    "aggs": {
      "brandAgg": { 
        "terms": { 
          "field": "brand", 
          "order": {
            "scoreAgg.avg": "desc" // 对聚合结果按照指定字段降序排列
          },
          "size": 20
        },
        "aggs": { // 是brands聚合的子聚合，也就是分组后对每组分别计算
          "score_stats": { // 聚合名称
            "stats": { // 聚合类型，这里stats可以计算min、max、avg等
              "field": "score" // 聚合字段，这里是score
            }
          }
        }
      }
    }
  }
  
  ```

  

### 9. 索引模板

#### 9.1 查看全部索引模板

```bash
ip/_template
```

#### 9.2 查看某个索引模板的内容

```bash
ip/_template/索引模板名称*
```

#### 9.3 创建索引模板

> 注意！！！es7以后，一个索引不再支持多个数据类型，只有一个默认的_doc。

```apl
# 创建一个名为mytemplate的索引模板，当创建名为mysqlaudit-开头的索引时生效。

PUT /_template/mytemplate

{
"order":1,
"index_patterns":["mysqlaudit-*"],
"mappings":{
   "properties":{
     "middleware_name":{
        "type":"keyword",
        "index":true
     },
     "k8s_pod_namespace":{
        "type":"keyword",
        "index":true
     },
     "query":{
        "type":"text",
        "index":true,
        "analyzer":"ik_max_word"
     }
    }
},
"settings":{
   "index": {
      "max_result_window": "30000000"
    } 
} 
}
```
