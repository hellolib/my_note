# 面试必知必会

- 面试强调（自学、学习能力）

## 一.基础知识点

### 1.基础

1. #### python内存管理机制

   - python中将所有的数据类型分为了两种；分别是:由多个元素组成的和单个元素组成的；以利用不同的结构体去区分，
     分别是：pyobject结构体（_ PyObject_HEAD_EXTRA 双向链表;ob_refcnt;引用计数器；_typeobject *ob_type 表示对象类型），
     一个是pyvarobject结构体(PyObject ob_base 内部包含pyobject结构体； obsize；此对象有多少元素组成 )
   - 在pytho代码中，如果创建对象或者是对对象赋值，内存中会对对象做两种操作：将对象加入双向链表，引用计数加1；
   - 如果执行对象删除操作，也会进行两步操作：引用计数器减一；如果引用计数为0，就将对象从链表中剔除；

2. #### python的垃圾回收机制？

   - 垃圾回收机制是以引用计数为主，以分代回收和标记清楚为辅；

     - 引用计数

       ```python
       在pytho代码中，如果创建对象或者是对对象赋值，内存中会对对象做两种操作：将对象加入双向链表，引用计数加1；如果执行对象删除操作，也会进行两步操作：引用计数器减一；如果引用计数为0，就将对象从链表中剔除；
       ```

     - **标记清除：引用计数可以满足基本的内存管理和垃圾回收，但是无法解决"循环引用"的问题,所以存在标记清除;**只有多个元素组成的才会产生循环引用；

       ```python
       # 循环引用
       v1= [1,2]
       v2=[3,4]
       v1.append(v2)
       v2.append(v1)
       # 在python内部维护了两个双向链表，一个单个元素组成，一个是多个元素组成的；在垃圾回收机制（GC）中会定期扫描由多个元素组成的链表，如果发现有循环引用存在，那么引用计数分别减一；
       ```

     - 分代回收：

       ```python
       分代回收：在python中为由多个元素的组成的类型（可能存在循环引用），为这些元素维护了三个双向链表，分别称为0代1代2代；python中为这三个链表设置了一个阈值，分别是700，10，10；（参数说明：如果第0代的链表中有700个对象时，进行一次扫描；0代扫描十次，一代扫描一次；一代扫描十次，二代扫描一次；极大的减少了扫描元素的个数）
       0代链表中item的个数达到700时进行十次扫描，标记清除，引用计数为0的从双向链表中删除；
       ```

        `你怎么知道这些？？？参考了一些文章和书籍：《python源码剖析》；我自己也会看一些python源码；`

   

3. **有没有学过其他语言？和其他语言的区别？**

   ```
   a. 先说py的特点：语言简洁、开发效率高、类库齐全（数据分析、机器学习）。
   b. JavaScript/Python/在自学Golang（自学）
   问题：Go和Python的区别？
   问题：为什么要学习Go？
   --------------------------------------------------
   大三大四自学Python,在校内学过C,不过已经忘记的差不多了,自学过Javascript,最近在自学Golang.
   Golang是编译型语言,为并发而生,相对其他高级语言是最接近c语言的一门语言,所以执行效率就特别的高,但是因为这门语言很年轻,所以他的第三方库相对pyhton来说比较少,框架也比较少,常用的就beego和buffalo;
   python是一门解释性语言,龟叔开发这门语言的初衷就是想让py代码简洁优美,python开发效率极快,同时又拥有功能丰富的第三方库,比如目前最火的数据分析和机器学习的类库.(numpy,pandas,matplotlib,sklearn,gensum)
   ------为什么学习Go?
   之前还不知道go语言,是先知道的docker,后来才了解到了go语言,再后来又通过一些技术博文了解到微服务,发现go做微服务也很厉害,就觉得这个go语言很牛逼,然后就想着去钻研下go语言,看看go语言到底在哪牛逼
   ------那你觉得go哪里牛逼?
   我目前还没用go语言做过项目,但是通过我自学这段时间我就这么觉得,go语言的基础代码并不比python复杂很多,还做过一个测试,go语言的执行效率和python不是一个级别的,要快很多.底层实现协程任务处理.
   ```

4. **python2和python3的区别？**

   ```
   解释器默认编码
   字符串字节
   经典类和新式类
   yield from
   字典的items/values/keys获取的是迭代器，py2中是列表。
   比如还有简单的：print、input、rang、range、int、long、除法
   --------------------------------------------
   1.最主要的就是默认解释器编码不一样,py2默认解释器编码是assic码,py3默认解释器编码是utf-8;
   2.然后一个区别就是字符串和字节不一样,py2里的unicode和str,python3里有str和bytes类型;
   3.新式类,py2里如果不继承object是经典类,继承了object才是新式类,py3中默认继承object,没有经典类;
   4.py2中只有yield,没有yield from关键字;
   5.字典的keys和values:py2中这两种方法返回的都是列表,python3中返回的是一个迭代器,节约内存资源;
   6.python2中只有进程池,没有线程池,py3中引入了线程池;
   这些都是些主要的区别,还有一些像print,input,range和Xrange,int和lang的区别等
   ```

5. **运算符**

   ```
   v = 1 and 8 or 9 and 0 or True
   --------------------------------------------
   数学运算>逻辑运算>(not>and>or)
   or判断时,第一个参数是True时结果就是第一个参数,第一个参数是Flase时结果就是第二个参数;
   and判断时,第一个参数是True时结果就是第二个参数,第一个参数是Flase时结果就是第一个参数;
   ```

6. **pass 的作用**

   ```python
   因为python的语法要求,像缩进,不符合语言的就会报错,pass关键字就是为了保证程序代码的结构正确,程序运行,其实不会执行任何操作,有点像占位符的意思;
   ```

7. ***arg和 * *kwargs的作用？**

   ```python
   万能形参;
   *arg是可以接收多个位置参数,并以元组的形式传递到函数内部;
   **kwargs可以接收多个位置参数,并以字典的形式穿点到函数内部;
   python中函数传参是引用传递
   ```

8. **列举数据类型的常用方法。**

   ```python
   # string，int，list，dict，set，tuple，Bool等
   str: str(),spli t,strip,upper,lower,repalce
   list:list(),append,extend,insert,remove,pop,count
   tuple: tuple(),count,index
   dict: dict(),keys,values,items,get,update，pop，popitem
   set: set(),remove,pop,update,add,difference,intersection,union
   ```

   ```python
   d = {'a':1,'b':2,'c':3}
   # 删除key值为'a'的元素，并赋值给变量e1
   e1 = d.pop('a')
   print(e1)
   # 如果key不存在，则可以设置返回值
   e2 = d.pop('m','404')
   print(e2)
   # 如果key不存在，不设置返回值就报错
   e3 = d.pop('m')
   
   # 字典popitem()方法作用是：随机返回并删除字典中的一对键和值。
   ```

   

9. **集合求交并差**

   ```
   交集：v1 & v2   (v1.interectinon(v2))
   并集：v1 | v2   (v1.union(v2))
   差集：
   	v1中存在，v2中不存在：v1 - v2  (v1.difference(v2))
   	v2中存在，v1中不存在：v2 - v1
   ```

10. **如下两个类型的 ((1),(2),(3)) 和 （1,2,3）的区别？**

   ```python
   (1) int
   (1,) tuple
   ```

11. **大文件操作**

    ```
    f = open(...)
    for line in f:
    	pass
    ---------------------------------
    通过for循环遍历读取,一行一行读
    ```

12. python库

    ```python
    # 内置库:
    re,json,time,random,sys,os,
    
    # 第三方库: request,scrapy,padans,numpy,pymysql,sqlalchemy
    转载: https://www.cnblogs.com/jiangchunsheng/p/9275881.html
    Requests  Kenneth Reitz写的最富盛名的http库。每个Python程序员都应该有它。
    Scrapy  如果你从事爬虫相关的工作，那么这个库也是必不可少的。用过它之后你就不会再想用别的同类库了。
    wxPython  Python的一个GUI（图形用户界面）工具。我主要用它替代tkinter。你一定会爱上它的。
    Pillow  它是PIL（Python图形库）的一个友好分支。对于用户比PIL更加友好，对于任何在图形领域工作的人是必备的库。
    SQLAlchemy  一个数据库的库。对它的评价褒贬参半。是否使用的决定权在你手里。
    BeautifulSoup  我知道它很慢，但这个xml和html的解析库对于新手非常有用。
    Twisted  对于网络应用开发者最重要的工具。它有非常优美的api，被很多Python开发大牛使用。
    NumPy  我们怎么能缺少这么重要的库？它为Python提供了很多高级的数学方法。
    SciPy  既然我们提了NumPy，那就不得不提一下SciPy。这是一个Python的算法和数学工具库，它的功能把很多科学家从Ruby吸引到了Python。
    matplotlib  一个绘制数据图的库。对于数据科学家或分析师非常有用。
    Pygame  哪个程序员不喜欢玩游戏和写游戏？这个库会让你在开发2D游戏的时候如虎添翼。
    Pyglet  3D动画和游戏开发引擎。非常有名的Python版本Minecraft就是用这个引擎做的。
    pyQT  Python的GUI工具。这是我在给Python脚本开发用户界面时次于wxPython的选择。
    pyGtk  也是Python GUI库。很有名的Bittorrent客户端就是用它做的。
    Scapy  用Python写的数据包探测和分析库。
    pywin32  一个提供和windows交互的方法和类的Python库。
    nltk  自然语言工具包。我知道大多数人不会用它，但它通用性非常高。如果你需要处理字符串的话，它是非常好的库。但它的功能远远不止如此，自己摸索一下吧。
    nose  Python的测试框架。被成千上万的Python程序员使用。如果你做测试导向的开发，那么它是必不可少的。
    SymPy  SymPy可以做代数评测、差异化、扩展、复数等等。它封装在一个纯Python发行版本里。
    IPython  怎么称赞这个工具的功能都不为过。它把Python的提示信息做到了极致。包括完成信息、历史信息、shell功能，以及其他很多很多方面。一定要研究一下它。
    ```

### 2.函数

1. **常用的内置函数**

   ```
   len、range、help、sum,max,min等,
   还有数据类型转换(str,list,dict,tuple,set)、进制转换(bin,oct,int,hex)
   ```

2. **高级的内置函数**

   ```python
   map/reduce/filter/zip
   a.函数的作用？
   b.写示例
   ----------------------
   #1.map 映射函数,循环每一个元素,对该元素执行函数操作,然后将结果返回到一个新的map可迭代对象中,可以转换为列表;
   v1 = [11, 22, 33, 44]
   result = map(lambda x: x + 100, v1)
   print(list(result)) 
   #2.filter 过滤函数,循环每一个元素,判断元素是否符合过滤条件,并将符合条件的结果保存到一个新的可迭代对象中,并返回;
   result = filter(lambda x: type(x) == int ,v1)
   print(list(result))
   #3.reduce 循环每一个元素,然后对元素进行自定义操作,然后将函数执行的结果保存到一个可迭代对象中并返回;
   result = filter(lambda x,y:x+y  ,v1)
   print(list(result))
   #4.zip zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。
   >>>a = [1,2,3]
   >>> b = [4,5,6]
   >>> c = [4,5,6,7,8]
   >>> zipped = zip(a,b)     # 打包为元组的列表
   [(1, 4), (2, 5), (3, 6)]
   >>> zip(a,c)              # 元素个数与最短的列表一致
   ```

3. **以下函数有什么坑？**

   ```python
   def func(a,b=[]):
   	pass
   ---------
   函数的形参如果是一个可变类型的话,在多次被引用并更改时时,该可变类型的形参的默认值也会更改,如果下次调用函数不传入该参数,将会使用更改后的b值;
   --面试注意打印顺寻
   ```

4. **什么是闭包？**

   ```python
   内部函数调用外部函数存储的数据。(1.必须存在嵌套,2.必须存在变量引用)
   def func():
   	v = 123
   	def inner():
   		print(v)
   	return inner
   data = func()
   data()
   ```

5. **装饰器 & 带参数的装饰器**

   ```python
   #普通装饰器
   def wrapper(func):
       def inner(*args,**kwargs):
           ret = func()
           return ret
      	return inner
   #带有参数的装饰器
   def foo(count):
       def wrapper(func):
            def inner(*args,**kwargs)
           	return func()
      		return inner
       return wrapper
   装饰器就是一个闭包函数，能在不改变原代码的基础上进行一些功能扩展
   类：类方法，和类的静态方法
   在Django中的使用：缓存、CBV的装饰器添加的时候、csrf装饰器、自定义标签、过滤器、还有信号注册等
   还有在Flask中也有用到，比如Flask中的路由系统、还有Flask中的特殊装饰器，beforrequest,afterrequest..
   ```
   
6. **列表生成式**

   ```python
   v = [lambda :x+10 for x in range(10)]
   result = v[3]()
   -->19
   # 新浪微博面试题
   v8 = [lambda x:x*i for i in range(10)]
   # 1.请问 v8 是什么？
   # 2.请问 v8[0](2) 的结果是什么？
   # 面试题
   def num():
   return [lambda x:i*x for i in range(4)]
   # num() -> [函数,函数,函数,函数]
   print([ m(2) for m in num() ]) # [6,6,6,6]
   ```

7. **什么是迭代器？**

   ```
   1.从前到后逐一迭代取值，只能向前无法倒退，可以使用内部的 __next__ 方法取值；
   2.比如一个类中含有——iter——方法，实例化的时候返回一个还有——next--方法的对象，这就是一个可迭代对象；
   
   v1 = iter([1,2,3,4,5,6])
   v1.__next__()
   v1.__next__()
   v1.__next__()
   next(v1)
   
   3.for 循环迭代的时候就是内部调用对象中的——next--方法
   ```

8. **什么是生成器？**

   ```python
   不再在内存中一次创建太多数据，而是生成器让它在使用的过程中再逐步创建，一个函数如果内部含有yield关键字，则此函数是生成器函数。
   
   # 生成器函数
   def func(count):
       while True:
           yield count
           count += 1
   
   # 生成器
   val = func(count)
   
   for i in val:
       print(i)
   ```
   
9. **函数的参数传递的是值？引用？**--引用!

   ```python
   # 引用
   def func(arg):
   	pass
   
   a = [11,22,33] # 引用计数器 1 
   func(a)        # 引用计数器 2
   # [11,22,33]内存中的引用计数器再次变成 1
   ```

10. **找文件夹下的所有文件**

    ```python
    os.walk
    -----
    import os
    
    def func(path):
        for p, d, f in os.walk(path):
            # p路径
            # d当前路径下的文件夹(列表形式)
            # f当前路径下的文件(列表形式)
            for i in f:
                print(i)
    
    path = r"D:\python_workspace\test"
    func(path)
    ```

11. **re模块中match和search的区别？**

    ```python
    # re.match
    只匹配开头,如果开头匹配成功,返回匹配的对象,如果不成功,则返回None
    # re.search
    遍历整个字符串,从头到尾从头匹配字符串中取出第一个符合条件的项.匹配成功re.search方法返回一个匹配的对象，否则返回None。
    --- re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回
    None；而re.search匹配整个字符串，直到找到一个匹配。
    ```

12. **什么是贪婪匹配？**

    ```
    在正则匹配中，贪婪匹配指的是尽可能多的去匹配符合条件的项,非贪婪匹配就是只匹配一个，通过在正则最后加 ？来控制。加?就是非贪婪匹配.
    ```

13. **给你一段HTML，请找到某个标签。**l

    ```python
    import re
    a = """<a href="/" id="result_logo" >"""
    ret = re.search('<a.*?href="(?P<href>.*?)"', a, )
    print(ret.group("href"))
    ```

14. **如何获取用户传入的参数**

    ```python
    sys.argv
    ---------
    $ python test.py arg1 arg2 arg3
    参数个数为: 4 个参数。
    参数列表: ['test.py', 'arlg1', 'arg2', 'arg3']
    ```

15. **@staticmethod和@classmethod的区别？**

    ```
    从传参和执行的角度
    --------------
    静态方法@staticmethod可以不进行传参,但是类方法@classmethod必须有一个参数cls;
    他们都可以通过实例化的对象调用方法,或者直接类名调用;
    ```

### 3.面向对象

1. **类变量**

   ```python
   class Base:
   	x = 1
   	y = 2
   class Foo(Base):
   	pass
   class Bar(Base):
   	pass 
   
   实例变量:类实例化后的对象内部的变量
   类变量:类中的变量,写在类的下一级和方法同一级。
   总结：找变量优先找自己，自己没有找 类 或 基类；修改或赋值只能在自己的内部设置
   class Base:
       x = 1
       y = []
   
   obj = Base()
   obj.x = [123]
   obj.y.append(1)
   obj.y = [123]
   print(Base.x)
   print(Base.y)
   print(Base.x)  -->1
   print(Base.y)  -->[1]
   # 找变量优先找自己，自己没有找 类 或 基类；修改或赋值只能在自己的内部设置
   # 类变量是可变类型时可以通过实例做全局修改,但是赋值还是只能在自己的作用域下进行,当类变量是不可变类型时实例只能在自己的额作用域修改类变量!!
   ```

2. **super的作用？**

   ```python
   # 根据类的继承关系（mro）向上继续找。
   
   class Base(object):
   	def func(self):
   		print('base.func')
   		super().func()
   
   class Bar(object):
   	def func(self):
   		print('bar.func')
   
   class Foo(Base,Bar):
   	pass 
   
   obj = Foo()
   obj.func()
   ```

3. **魔法方法（双下划线方法）**

   ```python
   1.__new__ 
   	a. 该方法的返回值是什么？
   	   # 未初始化的一个对象（一个内部没有数据的对象）
   		class Foo:
   			def __init__(self,name):
   				self.name = name 
   			def __new__(self,cls):
   				# 创建一个空的Foo类的对象
   				return object.__new__(cls)
   		obj = Foo('李朋')
   	b. 单例模式（加锁）
   		背写下来
   2.__init__ # 初始化方法: 用于给对象赋值
   3.__call__ # 实例化的对象后面加()执行__call__方法
   4.__enter__
   	__exit__
   	a. 做上下文管理的实例
   		with 类() as fff:
   			pass 
   5.__getitem__ # 对象通过索引取值
   6.__setitem__ # 对象赋值
   7.__delitem__ # 删除对象中的某个值
   	a. 对象通过索引取值
   		class HttpRequest(object):
   			def __setitem__(self,key,value):
   				pass
   				
   		session = HttpRequest()
   		session['x'] = 123
   		session['x']
   		del session['x']
   
   8.__add__  # 可以让对象进行加减操作
   	class Foo(object):
   		def __add__(self,other):
   			# self就是obj1
   			# other就是obj2 
   			return 666
   		
   	obj1 = Foo()
   	obj2 = Foo()
   	result = obj1 + obj2 
   9.__str__ 打印一个对像时,str返回什么打印什么
   10.obj.__dict__ # 去对象中找到所有变量并将其转换为字典
   ```

   - 面向对象的上下文管理

     ```python
     class Foo(object):
         def do(self):
             print("我已经做了点什么")
     
     class Context(object):
         def __enter__(self):
             print("我进来了")
             return Foo()
     
         def __exit__(self, exc_type, exc_val, exc_tb):
             print("我出来了")
     
     with Context() as item:
         print("这是哪呢?面向对象的上下文管理")
         item.do()
     ```

   - 线程安全的单例模式

     ```python
     # 线程单例模式
     from threading import Lock
     class Singleton(object):
     	instance = None
     	lock = Lock()
     	def __new__(cls, *args, **kwargs):
             if cls.instance:
                 return cls.instance
     		with cls.lock:
     			if not cls.instance:
     				cls.instance = object.__new__(cls)
     		return cls.instance
         
     ```

4. **什么是元类？**

   ```python
   Python中的类都是由type创建.
   	class Foo(object):
   		pass
   	等价于
   	Foo = type('Foo',(object,),{})
   通过metaclass可以指定类由谁来创建。
   	class Foo(object,metaclass=XXX):
   		pass 
   
   所以:# 元类就是用于指定当前类是由谁创建的.
   ```

### 4.网编与并发

1. **c/s和b/s架构？**

   ```python
   # C/S
   C/S结构即客户端/服务器，例如qq
   需要编写服务端程序，以及客户端程序例如我们安装的就是qq的客户端程序
   缺点：软件更新时需要同时更新 客户端和服务器端端，比较麻烦
   优点：安全性高
   # B/S架构
   B/S结构即浏览器/服务器
   优点：只需要编写服务器端程序
   缺点：安全性较差
   ```

2. **简述TCP三次握手和四次挥手。**

   ```python
   # tcp在建立连接时需要三次握手:
       1.accept接受过程中等待客户端的连接,当客户端发起连接时,会发起一个syn连接请求,
       2.服务端收到该连接请求之后会立即响应一个ack的响应,与此同时还会向客户端发送一个syn连接请求
       3.当客户端收到服务端的ack响应请求和syn连接请求之后,再向服务端回应一个ack的响应请求就可以建立tcp连接了
   # tcp的四次挥手:
       1.再客户端和服务端的代码中都有一个close方法,当有一方主动断开时,也就是执行close方法时,就是一次fin断开请求,在发出断开连接请求之后,如果收到对方的断开确认ack请求之后,就可以结束一段段额断开了,这样就是两次请求;
       2.当客户端和服务端双方都执行close方法,就会有两次断开请求和两次断开确认,这样就完成了连接断开,四次挥手;
   # 为什么连接是三次,而握手需要四次:
   因为在创建连接时,服务端收到客户端的连接请求后,会发送一个ack的响应和一个syn的请求,为了解决资源开销,这两个操作合并在了一起,就是三次握手了,但是在断开tcp连接的时候在一方断开请求的时候另一方可能还有数据正在传输,,为了确保数据传输的完整性,就需要四次挥手.
   ```

3. **OSI 7层模型。**

   - 应/表/会/传/网/数/物

   | 层级 |    名称    |        该层的协议         |     该层的设备      |
   | :--: | :--------: | :-----------------------: | :-----------------: |
   |  7   |   应用层   | 代码,http,https,ftp，smtp |                     |
   |  6   |   表示层   |                           |                     |
   |  5   |   会话层   |                           |                     |
   |  4   |   传输层   |       tcp/udp,port        | 4层交换机,4层路由器 |
   |  3   |   网络层   |         ipv4,ipv6         | 3层交换机,3层路由器 |
   |  2   | 数据链路层 |      arp协议,mac地址      |   2层交换机,网卡    |
   |  1   |   物理层   |                           |                     |

   - 教材上是写的是arp在网络层,但是很多人都认为在数据链路层;在**OSI**模型中**ARP**协议属于链路层；而在**TCP/IP**模型中，**ARP**协议属于网络层。

4. **TCP和UDP的区别？**

   ```python
   - tcp协议:是一个面向连接的,流式的(无边界),可靠地,慢的,全双工通信协议.
   应用场景:邮件发送,文件传输,http,web
   - udp协议是一个面向数据报的,不可靠,快的,能够完成一对多/多对多/多对一的高效通讯协议
   应用场景:即时聊天工具,视频在线观看
   ```

5. **什么是粘包？**

   ```python
   由于两端通信时，会经过计算机的缓存区，并且传输数据时是流式无边界,导致例如：A和B通信，A发送了2个数据包，B在接收时无法区分包，所以可能会获取错误。 
   为了解决此显现，我们通过struct模块自定义数据内容： 头信息|数据. 
   --------------------
   #概念
   粘包只会出现在tcp协议中;根本原因就是因为tcp是面向连接,传输的数据是流式无边界的,接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的!
   #发送端原因: 
   	由于TCP协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持
   一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是
   如果发送的网络数据包太小，那么他本身会启用Nagle算法（可配置是否启用）对较小的数据包进行合
   并（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。那么这样的话，服
   务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包.
   # 接收端原因: 
   服务器在接收到数据库后，放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取
   数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。
   # 解决办法:
   自定义消息的接收和发送协议:
       在每次使用tcp协议发送数据流时,在开头标记一个数据流长度信息,并固定该报文长度(自定义协议).在客
   户端接收数据时先接收该长度字节数据,判断客户端发送数据流长度,并只接收该长度字节数据,就可以实
   现拆包,完美解决tcp粘包问题.
   使用模块:struct模块,#该模块可以把一个类型，如数字，转成固定长度为4的bytes类型
   
   ```

6. **socket代码**

   - tcp协议

   ```python
   # server端
   import socket
   skt = socket.socket()
   skt.bind(("127.0.0.1",8080))
   skt.listen(10)
   
   cnt,addr = skt.accept()
   msg = cnt.recv(1024).decode('utf-8')
   print(msg)
   cnt.send("我是server".encode('utf-8'))
   cnt.close()
   skt.close()
   s
   # client端
   import socket
   skt = socket.socket()
   skt.connect(("127.0.0.1", 8080))
   skt.send("我是client".encode('utf-8'))
   msg = skt.recv(1024).decode('utf-8')
   print(msg)
   skt.close()
   ```

   - udp协议(type = socket.SOCK_DGRAM)

   ```python
   # server
   import socket
   
   skt = socket.socket(type=socket.SOCK_DGRAM)
   skt.bind(("127.0.0.1", 8080))
   
   msg, addr = skt.recvfrom(1024)
   print(msg.decode('utf-8'))
   skt.sendto("我是server".encode('utf-8'), addr)
   skt.close()
   
   #client
   import socket
   
   skt = socket.socket(type=socket.SOCK_DGRAM)
   skt.sendto("我是client".encode('utf-8'), ("127.0.0.1", 8080))
   msg = skt.recv(1024).decode('utf-8')
   print(msg)
   skt.close()
   ```

   - websocket协议

     ```python
     WebSocket 建立在 TCP 连接上的一种全双工通讯的协议。
     WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
     
     浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。
     当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。
     以下 API 用于创建 WebSocket 对象。
     var Socket = new WebSocket(url, [protocol] );
     以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。
     浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。
     
     当你获取 Web Socket 连接后，你可以通过 **send()** 方法来向服务器发送数据，并通过 **onmessage** 事件来接收服务器返回的数据。
     
     以下 API 用于创建 WebSocket 对象。
     
     ​```
     var Socket = new WebSocket(url, [protocol] );
     ​```
     
     以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。
     
     
     Django中的websocket的实现
     安装dwebsocket
     如果你想为一个单独的视图处理一个websocklet连接可以使用accept_websocket装饰器，它会将标准的HTTP请求路由到视图中。使用require_websocke装饰器只允许使用WebSocket连接，会拒绝正常的HTTP请求。
     ​		在设置中添加设置MIDDLEWARE_CLASSES=dwebsocket.middleware.WebSocketMiddleware这样会拒绝单独的视图实用websocket，必须加上accept_websocket 装饰器。
     ​		设置WEBSOCKET_ACCEPT_ALL=True可以允许每一个单独的视图实用websockets
     ```
   
   - http与websocket
   
     ```
       http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。
       http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。 
     
       WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。
       建立了WenSocket之后服务器不必在浏览器发送request请求之后才能发送信息到浏览器。这时的服务器已有主动权想什么时候发就可以发送信息到服务器。而且信息当中不必在带有head的部分信息了与http的长链接通信来说，这种方式，不仅能降低服务器的压力。而且信息当中也减少了部分多余的信息。
     ```
   
     
   
7. **断点续传的实现思路？（很少问）**

   ```python
   # 实现流程
   首次传输其流程如下
   
   1.服务端向客户端传递文件名称和文件长度
   2.跟据文件长度计算文件块数
   3.客户端将传输的块数写入临时文件(做为断点值)
   4.若文件传输成功则删除临时文件
   
   首次传输失败后将按以下流程进行
   
   1.客户端从临时文件读取断点值并发送给服务端
   2.服务端与客户端将文件指针移至断点处
   3.从断点处传输文件
   
   ```
   
8. **进程、线程、协程的区别？**

   ```python
   进程，计算机中资源分配的最小单元。 高计算的时候使用多进程
   线程，计算机中被cpu调度的最小单元。 
   协程，又称为“微线程”，与进程、线程不同，进程线程是计算机中真实存在，协程是程序员级别人为创造出来的，本质上通过一个线程实现并发的操作。 io多的时候使用线程
   
   一个进程中可以有多个线程、一个线程中有多个协程，他们都可以帮助我们完成并发操作，特殊协程只有遇到IO切换才有意义，否则效率反倒会降低。 
   -----------------
   # 进程(process):
   	进程是计算机中最小的资源分配单位,创建和销毁都需要一定的开销,进程有自己的pid,进程有三个状态,分别是就绪,运行和阻塞;数据隔离,数据不安全,由操作系统进行控制,可以利用多核;
   # 线程(threading):
   	线程是cpu最小的调度单位,创建和销毁也需要一定的开销,但是相对进程来说较小,也是由操作系统控制,数据共享,数据不安全,在cpython解析器下不能利用多核,因为gil锁；
   # 协程:
   	创建和销毁的开销极小,数据共享但是数据安全,不同利用多核,协程是通过代码来实现的
   一个进程中可以有多个线程、一个线程中有多个协程，他们都可以帮助我们完成并发操作，特殊协程只有遇到IO切换才有意义，否则效率反倒会降低。 --计算密集型用多进程、IO密集型用多线程。 
       -------
   #应用场景:
   # 在哪些地方用到了线程和协程
   1.自己用线程、协程完成爬虫任务
   2.但是后来有了比较丰富的爬虫框架
   # 了解到 scrapy /beautyful soup/aiogttp爬虫框架 哪些用到了线程，哪些用到了协程？
   3.web框架中的并发是如何实现的
   # 传统框架 ： django 多线程
   # flask 优先选用协程 其次使用线程
   # socketserver ：多线程
   # 异步框架 ：tornado，sanic底层都是协程
   ```

9. 进程之间的通讯

   ```python
   1.进程之间的数据是隔离的，但是数据仍然不安全；
   2.进程之间的通讯可以通过数据库，管道，队列Queue和manger类实现；还可以通过第三方消息中间件实现（redis，kafka，rabbitMQ实现）
   - 第三方IPC机制与内置IPC机制
   	- 第三方IPC机制--并发需求
   	- 第三方IPC机制--高可用
   	- 第三方IPC机制--断电保存数据
   	- 第三方IPC机制--解耦
   ```
   
   
   
10. **GIL锁的作用？**

    ```
    GIL，全局解释器锁。
    保证一个进程中同一时刻只有一个线程可以被CPU调度。
    
    计算密集型用多进程、IO密集型用多线程。
    可以在一定程度上保证数据安全：
    	- list/字典在调用内部方法时，是线程安全.
    		v = []
    		v.append(100)
    	- 其他操作，如果想要让线程安全，需要自动通过Lock或RLock来实现。 
    
    
    补充：在其他编程语言中没有GIL锁，这是Cpython解释器中特有。 
    ```


![1570089361587](C:\Users\big cattle\AppData\Roaming\Typora\typora-user-images\1570089361587.png)
    
38. **IO多路复用**

    ```python
    一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力。
    在socket连接中，有一个setblockint属性，将它改为flase就会变成非阻塞状态；但是s1.setBlockint(False)然后使用select或者poll或者epoll去监听对象的变化；
    
    监听多个IO对象是否发生变化（创建连接、收发数据）
    select：最多监听1024个IO对象；轮询的方式检查。windows,linux
    poll：不再限制IO对象的个数；轮询的方式检查。linux
    epoll:不再限制IO对象的个数；回调的方式进行检查。linux,效率最高!
    （事件驱动）
    
    示例：
        s1 = socket.socket()
        s1.bind(...8001)
        s1.listen(5)
    
        conn,addr = s1.accept()
    
    
        s2 = socket.socket()
        s2.bind(...8002)
        s2.listen(5)
    
        conn,addr = s2.accept()
        
        
        
        ---------------------------------
        
    	s1 = socket.socket()
        s1.bind(...8001)
        s1.setBlockint(False)
        s1.listen(5)
    
        conn,addr = s1.accept()
    
    
        s2 = socket.socket()
        s2.bind(...8002)
        s2.setBlockint(False)
        s2.listen(5)
    
        conn,addr = s2.accept()
        
        ---------------------------------
        s1 = socket.socket()
        s1.bind(...8001)
        s1.setBlockint(False)
        s1.listen(5)
    
        s2 = socket.socket()
        s2.bind(...8002)
        s2.setBlockint(False)
        s2.listen(5)
        
    	while True:
        	rlist,wlist,elist = select.select([s1,s2...],[],[],0.05)
        	for s in rlist:
        		conn,addr = s.accept()
        
        
    ```

### 5.数据库

1. **数据库引擎**

   ```
   InnoDB:mysql5.5版本后默认的存储引擎，支持事务，行级锁等。支持外键约束
   MyISAM:mysql老版本的存储引擎 只有表级索
   Memory：将数据存储在内存的引擎，速度极快，但是断电就会丢失；
   ```

2. [MySQL 视图、触发器、函数、存储过程](https://www.cnblogs.com/hukey/p/10396404.html)

3. 数据库索引的分类与原理

    https://www.cnblogs.com/bigox/p/11703328.html 

4. **事务的特性**

   ```python
   事务（Transaction）是并发控制单位，是用户定义的一个操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。
   原子性；一致性；隔离性；持久性；ACID 
   原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。
   # 原子性
   事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 。
   #一致性
   事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。比如，当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统在运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。
   # 隔离性
   一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
   # 持续性
   指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。
   ```

5. **Mysql怎么开启事务**

   ```python
   begin; # 开启事务
   select * from emp where id = 1 for update; # 查询id值，for update添加行锁；
   update emp set salary=10000 where id = 1; # 完成更新
   commit; # 提交事务
   ```

   - Django中开启事务：

     ```python
     #trans 反式
     #action 行为
     #atomic 原子
     from django.db import transaction
     try: #try要写在with之外,不然with捕获不到错误信息
     	with transaction.atomic():
     		# 进行一系列的ORM操作
     		models.Publisher.objects.create(name='xxxxx')
     		models.Publisher.objects.create(name='xxx22')
     except Exception as e :
     	print(e)
     ```

   - pymysql

     ```python
     try:
     	cursor.execute(sql) # 执行sql语句
     	db.commit() # 提交结果,增删改操作使用
     except:
     	db.rollback() # 发生错误时回滚
     ```

     

6. **上课讲的SQL语句题（看一遍）**

   ```python
   # 很重要!
   ```

7. **inner join和left join的区别？**

   ```
   inner join:找两张表共有的部分,两张表条件不匹配的项不会出现在结果中;
   left join:以左表为主,永远全量显示左表中的数据
   ```

8. **char和varchar的区别？**

   ```python
   char:char 定长字符串,如果字符长度不够定长,则系统会在末尾加空格补全,查询时也会自动去掉空格,查询速度快,但是浪费空间
   varchar:变长字符串,:节省空间,存取效率相对较低
   # 长度变化较小的用char字段
   ```

9. **varcha(50)，50代表什么意思？**

   ```
   50代表最多支持50个字符。
   ```

10. **笛卡尔积**（问的少）

   ```python
   现在，我们有两个集合A和B
   A = {0,1}     B = {2,3,4}
   集合 A×B 和 B×A的结果集就可以分别表示为以下这种形式：
   A×B = {（0，2），（1，2），（0，3），（1，3），（0，4），（1，4）}；
   B×A = {（2，0），（2，1），（3，0），（3，1），（4，0），（4，1）}；
   以上A×B和B×A的结果就可以叫做两个集合相乘的‘笛卡尔积’。
   从以上的数据分析我们可以得出以下两点结论：
   1，两个集合相乘，不满足交换率，既 A×B ≠ B×A;
   2，A集合和B集合相乘，包含了集合A中元素和集合B中元素相结合的所有的可能性。既两个集合相乘得到的新集合的元素个数是 A集合的元素个数 × B集合的元素个数;
   
   """
   有一个显而易见的SQL优化的方案是，当两张表的数据量比较大，又需要连接查询时，应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。
   """
   
   # 连接地址:https://www.cnblogs.com/cdf-opensource-007/p/6507678.html
   ```

11. **联合索引如何命中索引？**

    ```
    1.不能使用or查询；
    2.遵循最左前缀原则,在联合索引查询时,查询条件中必须含有创建联合索引时的第一个索引列(a,b,c),--查询条件
    中必须含有a;
    3.在整个条件中, 从开始出现模糊匹配的那一刻, 索引就失效了;
    ```

    - 不会命中索引的情况

      ```python
      1.如果条件中有 or ，索引不会命中
      2.查询的数据范围不能太大:like查询是以%开头，如果是int型索引不会命中，字符型的命中 'test%' 百分号只有在右边才可以命中。
      3.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引 
      4.对一列的内容区分度不高,索引不生效:没有查询条件，或者查询条件没有建立索引   
      5.索引列不能进行运算:查询条件中，在索引列上使用函数（ + , - , * , / ）, 这种情况下需建立函数索引
      6.联合索引遵循最左原则，不满足的不会命中  
      7,模糊匹配不会命中:like
      8,采用 not in, not exist
      ```

      

12. **mysqldump导入导出（笔试题）**

    ```
    mysqldump
    
    # 只导出表结构   mysqldump  -uroot -p123456  -d database > dump.sql
    # 导出表结构+数据  mysqldump  -uroot -p123456  database > dump.sql
    ```

13. **数据库优化方案**

    ```
    1.数据库读写分离
    2.做缓存（redis、memcached）
    3.分库分表
    4.使用索引&命中索引
    5.设计表结构时，用char代替varchar,把定长的列放在前后，变长的列放在后面。 
    6.有些数据放在内存，不要做连表查询（choices)
    	基于数据：
    		性别表
    			id  title
    			1   男
    			2   女
    		用户表
    			id  name gender_id
    			 1  王志勇   1 
    	基于内存：
    		用户表
    			id  name gender_id
    			 1  王志勇   1 
    		代码中：
    			(
    				(1,'男'),
    				(2,'女')
    			)
    ```

14. **数据库的索引类型**

    ```python
    主键索引（聚集索引）:主键索引的叶子节点存储的是整行数据,它是一种特殊的唯一索引，不允许有空值。
    唯一索引:MySQL数据库索引列的值必须唯一
    普通索引(辅助)：也被称为二级索引，叶子节点存放的是主键的值，使用普通索引查询时需要先找到主键，再通过主键索引搜索一次，此过程称为回表。
    联合索引：在多个字段上建立索引，只有在查询条件中使用了创建索引的最左N个字段或者最左N个字符，索引才会被使用，遵循最左前缀。
    
    全文索引：MyISAM引擎特有的。
    ```

    

15. **创建索引就应该命中索引，有哪些情况无法命中？**

    ```
    - like
    - 函数
    
    - like '%xx'
        select * from tb1 where name like '%cn';
    - 使用函数
        select * from tb1 where reverse(name) = 'wupeiqi';
    - or
        select * from tb1 where nid = 1 or email = 'seven@live.com';
        特别的：当or条件中有未建立索引的列才失效，以下会走索引
                select * from tb1 where nid = 1 or name = 'seven';
                select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
    - 类型不一致
        如果列是字符串类型，传入条件是必须用引号引起来，不然...
        select * from tb1 where name = 999;
    - !=
        select * from tb1 where name != 'alex'
        特别的：如果是主键，则还是会走索引
            select * from tb1 where nid != 123
    - >
        select * from tb1 where name > 'alex'
        特别的：如果是主键或索引是整数类型，则还是会走索引
            select * from tb1 where nid > 123
            select * from tb1 where num > 123
    - order by
        select email from tb1 order by name desc;
        当根据索引排序时候，选择的映射如果不是索引，则不走索引
        特别的：如果对主键排序，则还是走索引：
            select * from tb1 order by nid desc;
     
    - 组合索引最左前缀
        如果组合索引为：(name,email)
        name and email       -- 使用索引
        name                 -- 使用索引
        email                -- 不使用索引
    ```

    <https://www.cnblogs.com/wupeiqi/articles/5716963.html>

16. **慢日志**

    ```
    MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志,需要手动设置.
    ```

17. **数据库的执行计划**

    ```python
    MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个"EXPLAIN"即可。比如我们要分析如下SQL语句:
    explain select * from table where table.id = 1 ；
    运行上面的sql语句后你会看到，下面的表头信息：
    table | type | possible_keys | key | key_len | ref | rows | Extra
    预先知晓你的sql语句的效率；
    
    --词义解释：
    table ：显示这一行的数据是关于哪张表的
    type ：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL
    　　说明：不同连接类型的解释（按照效率高低的顺序排序）
    　　system：表只有一行：system表。这是const连接类型的特殊情况。
    　　const ：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。
    　　eq_ref：在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。
    　　ref：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。
    　　range：这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况。
    　　index：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。
    　　ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。
    ```

     ![img](https://images2018.cnblogs.com/blog/1293743/201806/1293743-20180624212049345-1652048025.png) 

18. **SQL注入**

    ```
    就是在输入字符串中嵌入SQL指令，在设计程序中忽略了对特殊字符串的检查，这些嵌入的指令便会被误认为正常的SQL指令，在数据库中执行，因此可以对后台数据库进行查看等工作，甚至破快后台数据库造成严重后果
    select count(1) from user where name = "%s" and pwd = "%s"
    select count(1) from user where name = "alex" and pwd = "123"
    select count(1) from user where name = "alex" or 1==1  -- " and pwd = "123"
    如何防止SQL注入：
    	- pymysql
    		cursor.execute("select count(1) from user where name = "%s" and pwd = "%s"",['alex','123'])
    	- ORM
    ```

19. **redis五大数据类型**

    ```python
    str 字符串
    list 列表
    hash 哈希类型
    set 集合
    sorted set  有序集合
    # 应用
    1.str： 用作缓存；
    2.还有一些session信息，也可以存到redis中，这样就可以防止频繁操作数据库
    3.分布式爬虫，还做消息队列的时候使用redis；scrapy-redis中的任务调度器，任务队列；
    4.还可以用redis的集合去重，用作增量式的一些东西，比如增量式爬虫
    ```

20. **redis的消息提醒数据结构(购物车的数据结构):**

    ```python
    receiver == {"user":{“goods”：count},"user":{“goods”：count}}
    ```

21. **redis和memcached的区别？**

    ```
    数据类型：redis有5种、memcached有一种数据类型。Memcached 只支持简单的 Key-Value 结构的数据记录 。
    持久化：redis支持持久化、memcached不支持。
    高可用：redis支持、memcached不支持。
    分布式集群：redis支持cluster、memcached不支持。
    -------------
    memcached没有这些但是通过一些手段可以实现持久化，集群，及高可用；
    ```

22. **redis的AOF和RDB什么区别？**

    ```
    AOF:基于日志做的持久化，保证数据的完整性。即：记录所有执行的命令，恢复时将所有命令执行一遍。
    RBD:基于快照做的持久化，速度快。即：定期对redis中的数据进行备份。
    ----我在redis中文网看到的
    ```

23. **redis过期策略。**

    ```
    redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。maxmemory-policy 六种方式:
    volatile-lru：只对设置了过期时间的key进行LRU（默认值） 
    allkeys-lru ： 删除lru算法的key   
    volatile-random：随机删除即将过期key   
    allkeys-random：随机删除   
    volatile-ttl ： 删除即将过期的   
    noeviction ： 永不过期，返回错误 
    ```

### 6.前端

1. **写出常用的bootstrap的样式（很少）**

   ```
   container
   table
   row
   form-control
   md-col-6
   ```

2. **什么是响应式布局？**

   ```
   根据用户设备不同，显示不同效果，内部使用了 @media属性实现。
   ```

3. **发送ajax请求**

   ```
   $.ajax({
   	url:'...',
   	type:"GET",
   	data: {},
   	dataType:"JSON",
   	success:funtion(arg){
   		
   	}
   })
   ```

4. **JavaScript与this相关的面试题**

   ```python
   # this
   函数是谁调用的,那么函数中的this就是谁,如果没有显示谁调用的,那么this对象全部都是widow!!!
   ```

   ```javascript
   name = 'alex'
   
   function f1(){
       console.log(this.name);
   }
   
   window.f1()
   ```
   
   ```javascript
   // 自执行函数
   (function(arg){
   	console.log(arg);
       console.log(this); // window
   })(123)
   ```
   
   ```
   name = '老男孩';
   
   info = {
   	name:'alex',
   	age:123,
   	func:function(){
   		console.log(this.name);
   	}
   }
   
   info.func() // 打印 alex
   ```
   
   ```javascript
   name = '老男孩';
   
   info = {
   	name:'alex',
   	age:123,
   	func:function(){
   		console.log(this.name);
           function f1(){
               console.log(this.name);
           }
           f1()
   	}
   }
   
   info.func() // 打印 alex; 老男孩
   ```
   
   ```javascript
   name = '老男孩';
   
   info = {
   	name:'alex',
   	age:123,
   	func:function(){
   		console.log(this.name);
           (function(){
               console.log(this.name);
           })()
   	}
   }
   
   info.func() // 打印 alex; 老男孩
   ```
   
   ```javascript
   name = '老男孩';
   
   info = {
   	name:'alex',
   	age:123,
   	func:function(){
   		console.log(this.name); // alex
           var xxx = this;
           (function(){
               // this依然等于window
               console.log(xxx.name); // alex
           })()
   	}
   }
   
   info.func() 
   ```
   
5. **“同源策略”、跨域、 jsonp、cors ?**

   ```
   浏览器具有“同源策略”，即：浏览器只能想当前所在的域发送Ajax，如果向其他域发送请求，则浏览器就会报错。 
   跨域会报错，因为浏览器具有浏览器具有同源策略。 但是，同源策略不对script标签中的src属性限制。
   
   如能才能跳过浏览器的同源策略，让我们向别的域可以发送ajax请求并获取结果？
   
   cors一个解决跨域的方案（设置响应头）。 主流
   	
   jsonp一个解决跨域的方案，是一种巧妙的机制，可以绕过浏览器的同源策略，实现跨域（动态创建script标签）。
   
   注意：jsonp只能发get请求
   
   扩展：域名、端口、二级域名不同都会引发跨域。 
   ```

   https://www.cnblogs.com/bigox/p/11610027.html

6. **前端框架**

   ```
   vue.js
   react.js
   angular.js
   ```

7. **http协议**

   ```python
   1.# http协议
   协议：http是超文本传输协议，是无状态、短链接应用层协议，规范了收发消息时请求和应答的标准，即规定了接收和发送消息的格式；默认端口为80；
   格式：请求和接受的格式：请求行，请求头和请求体组成；
   
   2.# 常见的请求头信息
   user-agent，用的什么浏览器设备。
   host 访问的主机名。
   accept 告诉服务端我能接受什么格式的数据。
   content-type，告诉服务器我给你发送的数据是什么格式？
   referer(防盗链：在博客园中插入一张csdn源的图片，就会被referer检测到，防止盗图)
   
   3.# 常见请求方式
   GET ,form表单时用于获取数据。restful api中用于获取数据。
   POST，form表单时一般用户添加和修改。restful api规范中用于添加。
   PUT，restful api规范中用于修改。
   DELETE，restful api规范中用于删除。
   OPTIONS，在解决跨域问题时，遇到复杂请求会先发送一个options请求做预检。
   PATCH，restful api规范中用于局部修改。
   
   4.# 常见的状态码
   200，成功。
   301，永久重定向。
   302，临时重定向。
   403，禁止访问。
   404，找不到页面。
   500，服务器错误         
   ```

   ```python
   #在浏览器地址栏键入URL,按下回车之 后会经历以下流程:(面试)
   
   1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应8的 IP 地址;
   2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
   3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
   4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
   5.释放(断开) TCP连接;
   6.浏览器将该 html 文本并显示内容;
   ```

### 7.框架

1. **https协议（简述你对Https协议的理解）**

   a. http协议是明文的不安全的。
   b. https是安全的，那么他是如何实现安全的呢？

   - 对称加密，两端用同一个密码进行加密和解密。
   - 非对称加密，公钥，专门用于加密。私钥，专门用于解密。

   c. https的实现过程？

   ```python
   #https是加密的http协议，https = http+ssl
   对称加密和非对称加密：
   	对称加密就是客户端服务端都有密钥，客户端通过密钥加密的数据传输给服务器，服务端通过密钥解密加密数据，如此进行收发消息；
   	非对称加密就是服务端将公钥发送给客户端，客户端使用公钥加密对称密钥，然后将加密的对称密钥发给服务端，服务端通过私钥解密，获取对称密钥，然后客户端和服务端都有了对称密钥，就可以通过对称加密收发消息；
   # https的加密方式是通过证书加密；
   	1.服务端向第三方机构申请ca加密证书（阿里云免费一年），该证书中包含公钥和企业信息；
       2.客户端发起请求，服务端将证书发送至客户端，自己保留私钥；
       3.客户端收到证书之后会校验证书的合法性；
       4.客户端获取到证书也就获取到了公钥，然后客户端通过公钥将对称密钥加密，传递给服务端；
       5.这样客户端和服务端就都有了对称密钥，双方都可以通过该密钥对数据加密解密；完成加密收发消息
       
   # http和https的区别
   1.端口不同：http默认端口是80，https的默认端口是443
   2.http协议数据明文不安全，https是加密后传输，数据安全；对称秘钥是客户端生成并通过非对称密码加密发送给
   服务端。非对称密码是客户端在第一次访问时集成在证书中返回给客户端（客户端会对证书进行验证）
   ```

   - 非对称加密过程

     ![1570534381155](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570534381155.png)

2. **Django和Flask的区别，优缺点？**

   ```python
   Django是一个重量级的框架，框架中封装的功能特别齐全，例如：ORM、Form组件、ModelForm、ModelFormSet、middleware、Tags、缓存、信号、多数据库连接和读写分离等；
   Flask是一个轻量级的框架，但是他的第三方组件特别齐全；
   
   他们之间还有一个最最重要的区别就是对请求的处理的不同，在Django中是基于将请求传递实现，而在Flask中是基于上下文管理实现（最近我也在研究Falsk的上下文管理机制和源码）；两个框架不是同的实现机制，代表不同的思想，优劣没有什么可比性，都是很不错的web框架；
   ```

   ```python
   # 自定义标签
   1. 在app下创建一个名为templatetags的python包(名称不能变)
   2. 在templatetags 创建py文件 自定义名称 my_tags.py(名称自定义)
   3. 在py文件中写入:
   from django import template
   	register = template.Library() # register也不能变
   4. 写函数+装饰器
   @register.filter
   def add_xx(value, arg): # 最多有两个
   	return '{}-{}'.format(value, arg)
   #缓存
   6中模式： 
   开发调试缓存
   内存缓存 redis
   文件缓存
   数据库缓存
   Memcache缓存(使用python-memcached模块)
   Memcache缓存(使用pylibmc模块)
   
   #信号
   Django的信号机制就是事件驱动模型，一个事件可以被多个函数注册，当一个动作行为触发了这个事件后，这个事件所对应的函数便执行相应的操作;
   内置信号;
   
   模型相关：
   
   pre_save 对象save前触发
   post_save 对象save后触发
   pre_delete 对象delete前触发
   post_delete 对象delete后触发
   
   请求相关：
   request_started 一个request请求前触发
   request_finished  request请求后触发
   ```

   - Django的读写分离

      https://www.cnblogs.com/bigox/p/11698941.html 

3. **Flask框架；**

   - 项目目录结构

     ```python
   参考Django的目录结构
     ```

   - 扩展很多（可扩展性强）

     ```python
     flask-sqlalchemy
     	执行原生sql语句，类似于django中的orm
     flask-session
     	灵活存取session到其他地方，类如redis
     flask-script 
     	1.使用python manage.py runserver启动项目；
     	2.自定义命令: 位置传参和关键字传参
     flask-migrate
     	# 帮助我们做数据库迁移　　　　# 依赖：flask-script 
     wtforms
     	1.生成HTML标签
     	2.form表单验证
         
     DBUtils数据库连接池
     	两种连接模式：
     		1.为每一个线程创建连接, 线程即使调用了close也不会关闭, 只是
             把连接重新放到连接池, 供【自己线程】使用. 当线程终止时, 连
             接自动关闭.
             2.创建一批连接大连接池, 供【所有线程】使用 【推荐】
     ```

   - Flask内置的内容

     ```python
     1.环境依赖（Werkzeug，Markupsafe，Jinja2）；
     2.路由系统（装饰器的应用场景）；
     3.模板Jija2；
     4.特殊的装饰器；
     	（before_request在请求访问之前执行被装饰的函数
     	  after_request访问之后执行被装饰的函数）
     5.蓝图（作用：对业务逻辑代码进行划分）
     # flask中的蓝图和django中的app有什么区别？
     他们两个做的都是同样的事情，都是对业务逻辑进行拆分（简单业务时没必要用蓝图和多app）。
     ```

   - 上下文管理：

     ```python
     # ctx= RequestContext 请求上下文
     # app-ctx = ApplicatContext  应用上下文
     # Localstack（）对象的作用就是为了将local对象列表维护成一个栈，方便数据处理；
     1. 请求到来的时候，会执行一个叫run_simple方法，然后执行__call__方法，内部封装一个叫做ctx对象，这个ctx中包含了request对象（请求信息）和session信息（会话信息）；
     2. 首先会调用ctx.push的方法；封装ctx并把ctx对象放到全局中去；
     	2.1 在执行cts.push方法的过程中会创建一个app-ctx对象，在ctx对象中封装了app和g两个对象；
         2.2 然后会执行app-ctx对象中的push方法，目的是跟ctx-push方法一样封装和推送：
         	2.2.1 在app-ctx对象中的push中会先找到一个_app_ctx_stack对象，然后调用_app_ctx_stack.push()方法，这个对象是一个全局变量_app_ctx_stack=Local_stack(),也就是在执行Local_stack()中的push方法；
             2.2.2 Local_stack()的push方法会通过反射去找到一个叫做local对象，并获取其中的stack,stack是一个列表；
             2.2.3 在local对象会获取当前线程ID,并且会维护一个字典，字典的key就是线程id，值也是一个字典，子字典的键是stack，值是一个列表，将app_ctx添加到stack列表中；''' {线程id：{“stack”：[app_ctx]}} '''
         2.3 在把app-ctx的push方法执行完毕之后会把ctx的push方法也执行完毕：
         	2.3.1 类似于_app_ctx_stack对象，会找到一个叫做_request_ctx_stack然后调用_request_ctx_stack.push()方法，这个对象是一个全局变量_request_ctx_stack=Local_stack(),也就是在执行Local_stack()中的push方法；
             2.3.2 Local_stack()的push方法会通过反射去找到一个叫做local对象，并获取其中的stack,stack是一个列表；
             2.3.3 在local对象会获取当前线程ID,并且会维护一个字典，字典的key就是线程id，值也是一个字典，子字典的键是stack，值是一个列表，将ctx添加到stack列表中；
         2.4 最后给ctx中的session赋值；
         
     # 请求下文：
     3. 执行视图函数，其实request就是一个Localproxy对象，例如在调用requst.args属性时，执行该对象的__getattr__方法， 执行一个偏函数，找到
     oack对象，然后执行一个top方法，_request_ctx_stack被Localstack维护成了一个栈，所以会获取到栈的栈顶对象，也就是一个ctx对象，然后ctx中封装着request，这样就是requst.args就是ctx.request.args了
     # 给用户返回数据：
     4. 给用户返回数据，并将local中的ctx和app—ctx移除；
     ```
     
     ![1570759821955](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570759821955.png)

4. **django请求的生命周期**

   ```python
   1.请求到来之后，先到达wsgi（本质实现了socket服务端，用于接收用户请求，wsgi是web服务网关接口，实现此协议有wsgiref、uwsgi），对请求做了封装处理之后，将请求转交给django；
   2.请求到达django中间件，执行中间件中的process_request方法；
   3.接下来请求到达django中的路由系统，进行路由匹配；
   4.然后执行中间件的process_view方法（一旦出错就会执行中间件process_exception方法）；
   5.然后执行视图函数，视图函数可以对数据库进行操作，也可以调用模板进行模板数据渲染；
   6.接下来倒序执行中间件中的process-response方法；
   7.最后将响应对象通过wsgi返回给用户；
   在其中呢中间件说的比较模糊，其实经常用的中间件有5中方法，他们分别为：
   ```

5. **Django中间件的作用及应用场景？**

   ```python
   	Djnago中间件就是一个全局钩子，可以在请求到来前和请求处理之后进行一些功能扩展，或者叫做额外操作，其中用到的5种方法：见下图：
   # 应用场景：
   1.自定义权限组件中，使用中间件用作权限控制；
   2.Django内置的中间件实现了session功能；
   3.Django内置的中间件实现了CSRF验证；
   4.可以通过中间件解决跨域问题，使用Django-cors-headers实现跨域解决；
   5.做缓存的时候用；
   6.用户认证、还可以做用户的访问次数限制；
   7.还可以实现黑名单和白名单；做日志管理；
   ```

   - view报错

     ![1570627749490](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570627749490.png)

   - view不报错

     ![1570627776485](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570627776485.png)

6. **Django中路由设置name的作用，csrf的校验流程**

   ```python
   # name的作用：
   	基于名字反向生成URL
   ```

   - csrf 校验

     ```python
     # csrf装饰器
     csrf_except  某个视图不需要进行csrf校验,在CBV上使用时 必须加在dispath方法上
     scrf_protect   某个视图需要进行csrf校验
     ensure_csrf_cookie  确保生成csrf的cookie,在中间件被禁用时,可以生成csrf验证cookie
     # csrf 校验流程
     1. csrf中间件执行prosecc_request方法:
     从cookie中获取到csrftoken的值，把从csrftoken的值放到request.META中,META['CSRF_COOKIE']=csrftoken
     2. 然后执行procss_view方法：
     	- 查看视图是否使用csrf_exempt装饰器,使用了就不再进行csrf校验
     	- 然后判断请求方式:
     	2.1.如果是'GET', 'HEAD', 'OPTIONS' 不进行csrf校验；
     	2.2.如果是其他的请求方式(post，put)进行csrf校验
     		-首先获取cookie中csrftoken的值即META['CSRF_COOKIE'],
     		-再获取name=csrfmiddlewaretoken的值,即from表单中隐藏标签里的值,
     			----如果能获取到值-->赋值给request_csrf_token
     			----如果获取不到,就去请求头中寻找x-csrftoken的值,-->赋值给request_csrf_token
     最后比较上述request_csrf_token和cookie中csrftoken的值，比较成功接收请求，比较不成功拒绝请求。
     ```

   - ajax的csrf校验

     ```python
     # 前提条件:确保有csrftoken的cookie
     	在页面中使用{% csrf_token %}
     	或者对视图函数加装饰器加装饰器 ensure_csrf_cookie
     方式一: 给data中添加csrfmiddlewaretoken的值
     data: {
     	'csrfmiddlewaretoken':$('[name="csrfmiddlewaretoken"]').val(),
     	a: $("[name='i1']").val(),
     	b: $("[name='i2']").val(),
     	},
     方式二: 加请求头
     headers:{
     	'x-csrftoken':$('[name="csrfmiddlewaretoken"]').val(),
     },
     方式三:使用js文件
     	使用js文件的原理就是在请求头中加入x-csrftoke的值
     ```

     

7. **Django中FBV和CBV有什么区别？**

   ```python
   FBV就是在视图中写函数处理业务逻辑。
   CBV就是在视图中写类处理业务逻辑。 
   这俩本质是一样的，因为CBV的内部是基于闭包和反射来实现调用类中的get/post等方法。CBV在url中调用的时需要在类名之后加上.as_view()方法
   #as_view（）方法的执行流程
   1.在代码加载的过程中执行该方法，会返回一个view函数；
   2.在请求到来的时候会调用view函数：
   	（1）view函数内实例化该CBV的类，并将对象赋值给self,让后将request封装到该self对象中；
       （2）view函数会调用dispatch方法；
       （3）在dispatch方法中会对判断该请求的请求方式进行判断：
       （4）如果请求方式合法就通过反射调用该方法，如果不被允许就会报错。
   # 提醒：CBV中如果用装饰器就要使用特殊method_decorator.
   ```

8. **django orm中如何批量创建数据？**

   ```
   models.UserInfo.objects.bulk_create([UserInfo(name='xx'),UserInfo(name='xx')],size=10)
   
   # bulk_create中传入的参数必须是一个列表
   ```

9. **django orm中Q的作用？**

   ```
   用于构造复杂的搜索条件。& | 
   ```

10. **django orm中F的作用？**

    ```
    获取数据库中某个数据并对他做操作。
    
    例如：用户表中包含用户信息和薪水，请通过ORM将所有用户的薪水在自己原来薪水基础上+1000. 
    models.UserInfo.objects.all().update(salary=F('salary')+1000)
    ```

11. **django orm 中如何执行原生SQL？**

    ```python
    # extra  --额外
    	Entry.objects.extra(where=["foo='a' OR bar = 'a'","id>%s"], params=[9])
    # raw  --原，生
    	UserInfo.objects.raw('select * from userinfo')
    # connections  --连接 
        from django.db import connection, connections
        cursor = connection.cursor()  # cursor = connections['default'].cursor()
        cursor.execute("""SELECT * from auth_user where id = %s""", [1])
        row = cursor.fetchone() # fetchall()/fetchmany(..)
    ```

12. **使用django的orm实现 id不等于5的数据。--exclude()**

    ```
    models.UserInfo.objects.exclude(id=5)
    ```

13. **用inclusion_tag或simple_tag实现在模板中自定义方法。**

    ```python
    1. 在app下创建一个名为templatetags的python包(名称不能变)
    2. 在templatetags 创建py文件 自定义名称 my_tags.py(名称自定义)
    3. 在py文件中写入:
    @register.simple_tag(name="plus")
    def plus(a, b, c):
    	return "{} + {} + {}".format(a, b, c)
    4.使用：
    {% load my_tags %}
    
    {# simple tag #}
    {% plus "1" "2" "abc" %}
    
    
    ```

    - inclusion_tag

    ![1570633549404](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570633549404.png)

14. **cookie和session的区别？**

    ```
    cookie是保存在客户端浏览器上的键值对。 
    session是保存在服务端的数据，session依赖与cookie。
    因为cookie是将数据保存到客户端，数据在用户浏览器可能就存在隐患，所以他是不安全的。 session是将数据放在服务端，在客户端只保存一个随机字符串（sessionid)。
    ```

### 8.GIT协同开发

 https://www.cnblogs.com/bigox/articles/11626092.html 

1. **写下常见用的git命令**

   ```python
   git init  托管文件夹
   git status 
   git add .
   git commit
   git log
   git reflog
   git reset
   git clone2
   git branch   创建分支（‘不软吃’）
   git checkout 
   git merge  合并分支数据
   git push
   git pull
   ```

2. **你们公司/团队用的什么做的协同开发？如何做的？**

   ```
   git + github/gitlab/码云
   gitlab
   master分支
   每个人一个dev分支，在自己分支开发自己的功能。
   还有一个review分支，推到review做代码审核；
   ```

3. **公司如何做代码review？谁来做？**

   ```
   通过pull request（PR）来做review。 
   提交给小组长。
   ```

4. **线上代码如果出现bug如何解决？**

   ```
   创建一个bug分支，专门用于修复紧急bug。 
   ```

5. **什么是restful api？【最新】**

   - 基本准则

     ```python
     1. 网络上的所有事物都可以抽象为资源
     2. 每个资源都应该有唯一的标识（identifier），对资源的操作不会改变标识
     3. 所有的操作都是无状态的
     4. 使用标准方法（GET、POST、PUT、PATCH、DELETE）操作资源
     ```

   - 规范建议

     ```python
     1. 最好用https代替http;
     2. url中一般有api标识：http://www.luffyciyt.com/api/
     3. url中一般有版本：http://www.luffyciyt.com/api/v1/
     4. url必须有名词：http://www.luffyciyt.com/api/v1/user
     5.method不同做不同操作
     	get  查询
     	post  添加
     	delete  删除
     	put  更新
     6.响应数据使用json字符串
     7.响应使用标准的状态码
     8.错误处理{'error':"错误"} error为键
     ```

   - RESTful的认识

     ```python
     RESTful就是规范，让写API的时候更改规范，更好记，体现某些操作，之前不知道restful的时候也没什么影响，后来知道了感觉还可以，就让自己更规范了，但是还是很多规范没有用到，比如https代替http，这个个人开发不太可能；比如跨域的时候也不使用该规范了，复杂请求会发送options请求做预检，跨域解决。。。cors和jsonp。。。
     ```

6. **什么是webservice?【以前】**

   ```
   程序之间进行数据交互时，必须遵守的规范。
   响应的数据是xml格式
   ```

7. **什么是RPC？**什么是IPC？什么是ARP协议？

   ```python
   IPC：进程之间的通讯；
   ARP：地址解析协议,通过ip地址获取mac地址协议，二层交换机的功能；
   RPC：RPC是远程过程调用（Remote Procedure Call）程序与程序之间做数据交换的一种方式，基于队列实现通信；每有一个socket连接都会创建两个队列供两端通信使用
   - RPC队列在任务较多的时候可以做缓冲，类似于生产者消费者模型
   - RPC比restFul的http通讯要快
   ```

   ![1570629625100](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570629625100.png)

8. **RESTful API**

   ```python
   RESTful就是规范，让写API的时候更改规范，更好记，体现某些操作，之前不知道restful的时候也没什么影响，后来知道了感觉还可以，就让自己更规范了，但是还是很多规范没有用到，比如https代替http，这个个人开发不太可能；比如跨域的时候也不使用该规范了，复杂请求会发送options请求做预检，跨域解决。。。cors和jsonp。。。
   ```

   ```python
   1. 网络上的所有事物都可以抽象为资源
   2. 每个资源都应该有唯一的标识（identifier），对资源的操作不会改变标识
   3. 所有的操作都是无状态的
   4. 使用标准方法（GET、POST、PUT、PATCH、DELETE）操作资源
   ```

   - 规范建议

     ```python
     1. 最好用 https 代替 http;
     2. url中一般有api标识：http://www.luffyciyt.com/api/
     3. url中一般有版本：http://www.luffyciyt.com/api/v1/
     4. url必须有名词：http://www.luffyciyt.com/api/v1/user
     5. 筛选条件，http://www.luffyciyt.com/api/v1/user/?age=10
     6.method不同做不同操作
     	get  查询
     	post  添加
     	delete  删除
     	put  更新
     7.响应数据使用json字符串；
     8.响应使用标准的状态码；
     9.错误处理{'error':"错误"} error为键；
     10.返回结果时详细信息可以以url返回；
     ```

9. **Django REST Framework 框架的作用：**

   ```python
   帮助我们快速开发遵循restful规范的接口，它的内部帮我们实现了很多功能，例如：认证、权限、节流、序列化、渲染、版本管理。
   ```

10. **你使用过的DRF写视图的时候，都继承过哪些视图类？**

    ```python
    ApiView 认证、权限、节流、序列化、渲染、版本管理，自定制功能；(10个功能)
    GenericAPIview 规划路线，指定如果获取数据必须先执行self.get_queryset方法，内部又会去调用类变量queryset，用到了断言 .（很少用）
    ListAPIView  get请求查看功能
    CreateAPIView  增加 数据
    RetriAPIView 获取单数据
    DestroyAPIView  删除数据
    UpdateAPIView  更新功能
    ModelViewSet  更删改查功能
    ```

11. **GenericAPIView 视图类的作用?**

    ```python
    规划请求的路线，例如指定如果获取数据必须先执行self.get_queryset方法，内部又会去调用类变量queryset，用到了断言 .（很少用）
    get_queryset
    get_serializer
    ```

12. **DRF APIView中认证组件的实现过程？**

    ```python
    1.请求进来，执行dispatch方法，对request进行封装；封装时执行get_authenticators()方法，该方法中是一个列表推导式，循环authentication_classes，并将类实例化为对象,最后返回一个对象列表;authentication_classes默认是api_setting文件中的一个配置对象;自己定制功能的时候需要自己定义一个对象列表，authentication_classes = [Authtication，]；现在request中包含了自定义类的对象了；
    
    2. 然后执行initial方法；
    	2.1 在initial方法执行时，执行perform_authentication方法调用了request.user方法，userhi一个属性方法，执行user方法；
        2.2 在request.user中调用_authenticate()方法，该方法会循环所有的request对象（该对象是在第一步自定义的Authtication对象），然后执行自定义对象中的authenticate方法；
            2.2.1 如果自定义类的authenticate方法中抛出异常会执行not_authenticated（）方法，认证失败；
            2.2.2 如果自定义的类方法authenticate方法中有返回值，必须是一个元组，饭后将返回值分别赋值给request.user和request.auth；
            2.2.3 如果没有返回值的话返回None表示当前认证类不处理这个认证，交给下一个认证类处理；如果每一个自定义认证类都不处理，那么就会设置一个默认值（匿名用户，未登录）；
    3.认证完毕，执行get/post方法
    ```

    ![1570778327031](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570778327031.png)

    ![1570779197107](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1570779197107.png)

13. **写爬虫的过程中都遇到哪些反爬机制？**

    ```python
    1.robots.text 君子协议
    2.UA限制:User-agent
    3.Headers：抓包工具获取到请求头的信息手动加入
    4.IP限制：IP代理
    5.验证码：超级鹰破解
    6.模拟登录验证
    7.Ajax动态加载：找到请求的url
    8.数据懒加载：selenium
    9.js加密：找到加密方式，使用pyexejs模块模拟执行js；
    10.js混淆：isjson序列化
    11.动态的token：获取到动态传值，然后再将动态值传入请求当中
    ```

14. **企业给一个爬虫题，爬完发给面试官；**

    ```python
    靠自己，找老师，找同学
    ```

15. **常见爬虫框架和爬虫模块；**

    ```python
    模块：request,urllib,bs4,xpath，BeautfulSoup；
    框架：aiohttp,scrapy,scrapy_redis
    ```

### 9.Linux

1. **常用的linux命令和服务：**

   ```python
   # 命令
   ssh　ping sudo  ifconfig
   ls cd  find　search whereis whatis 
   touch mkdir tar　gzip bzip2　unzip
   ps　free　top　df
   kill　rm  mv　cp
   yum　rpm　　wget vim　date　time
   tail 
   
   netstat -ntulp |grep 80  查看一个端口是否在运行服务
   top 查看内存 free
   ps / ps aux 查看进程
   grep　　sed　　vim　　diff　　sort　　export　　args　　pwd　　　shutdown　　ftp　　crontab　　service　　mount　　chmod　　chown　　passwd　　uname　　locate　　man　　tail　　less　　su　　mysql　　
   # 服务
   crontab 定时服务
   nginx 服务
   uwsgi 服务
   mysql 
   redis 
   RabbitMQ 消息队列
   
   # 查看进程
   ps aux
   # 查看内存
   free 
   ```

2. **你看过的官方技术文档；**

   ```python
   rabbmitMQ 和 Flask 官方文档 (最好的)；
   	写给小白，真正的学习文档，易懂！
   DRF 框架官方文档（最差的）；
   	写给会的人，可以让会的人去查询！
   ```

### 10.项目

1. **crm项目**：

   - ###### 为什么要自己开发 crm 项目，而不去用现成的？

     ```PYTHON
     用2年开发了crm项目，其中一只在进行项目的维护和新功能的迭代（由于直接对业务方可能存在功能变动）
     买了一套学邦boss系统（内置只有通用的功能）
     切换回去用crm。
     -----
     公司用过现成的,学邦的，但是效果不好，定制功能太贵了，还有很多无法第三方定制；
     ```

   - ###### crm项目实现了哪些功能？

     ```python
     - 项目解决公司销售人员日常客户维护的事宜，对于推广人员录入到公户的客户属于所有销售的共同资源，每个销售都有自己的私户，对于自己私户人员可以一直由自己维护（其他人如果成单提成依然归当前用户），每个私户最多有150个客户信息。 
     - 对于所有客户信息需要销售进行定期的客户跟进。 
     - 对于成单客户端需要维护客户信息，购买订单记录等。 
     - 根据区域和等级对用户信息处理和划分。 
     - 对销售的年度、季度、月度、周进行销售排名的同级。 
     - 对于用户角色的划分以及权限管理（为公司开发了一个通用的权限组件）。 
     ---------------------------------------------------------------
     2.客户管理：
     	客户信息展示(公私户的转换)
         新增 编辑 删除客户信息
         客户等级划分
         公私户的转换
     3.客户的跟进记录管理
     	查询当前销售的所有的跟进记录
         查询某个客户的所有的跟进记录
         对跟进记录进行增删改
     4.成单记录管理
     	查询当前销售的所有客户的成单记录
         查询某个客户的购买记录
         成单表的增删改
     5.收款记录管理
     	查看当前销售的所有客户的所有缴费记录
         查看某个客户的所有收款
         收款记录的增删改
     ```

   - 技术要点 

     ```python
     给不同的用户分配不同的功能,这里主要阐述的是基于角色的权限控制rbac(role based access control)
         在web开发中,一个url就可以看做是一个权限
         控制流程:
         1.分页功能，
         2.Form组件(modelform) 对表进行增删改查，
         3.模糊查询(Q对象)，
         4.分页保留源搜索条件(QueryDict)，
         5.url命令和反向解析
         6.修改或新增后跳转到原界面
         7.加锁,事务 公私户的转换
         8.限制choice的选择
         9.中间件,登录校验,登录成功后返回原网址
         10.母版的继承
         11.自定义temple_tag
     ```

2. **rbac权限控制系统：**

   1. ###### 权限是如何实现的？

      ```python
       在web开发中,一个url就可以看做是一个权限,表+中间件事项的权限认证
      ```

   2. ###### 权限组件中有哪些表？表中都有哪些字段？

      ```python
   6张表
          menu(id,name,icon,weight)
          permission(id,url title name icon menu parent)
          role(id,name permissions)
          user(id,username password roles)
          user与role的多对多关系表(id user_id role_id)
          role与permission的多对多的关系表(id role_id permission_id)
      ```
   
   3. ###### 权限中如何实现粒度控制到按钮级别？

      ```python
   当用户登录成功之后，会将该用户所有权限信息放入session中，session中保存所有权限信息，格式如下：
      session.permission = {
   	user_list:'/user/xx/xxxx/ulist/',
      	user_list:'/user/xx/xxxx/ulist/',
      	user_list:'/user/xx/xxxx/ulist/',
      	user_list:'/user/xx/xxxx/ulist/',
      	user_list:'/user/xx/xxxx/ulist/',
      	user_list:'/user/xx/xxxx/ulist/',
      }
      
      在每个页面中按钮部分会做判断。
      if user_add in session.permission:
      	<a>编辑</a>
      else:
      ```
   
      
   
   4. ###### 权限是否可以粒度控制到数据行？

      ```python
      当时在讨论这个功能要不要实现，但是最后没有应用到项目中；说一下思路吧：
      额外创建一张level；
      表中
      ```
   
      ![1571661792773](C:/Users/big cattle/AppData/Roaming/Typora/typora-user-images/1571661792773.png)
   
5. ###### 权限为什么要放到session中？
   
   ```python
      权限信息是保存在数据库中，用户登录成功后会将权限信息放入session，目的是提高效率，不需要每次请求时在去数据库做各种查询。 
   放入session有没有什么不好之处？无法进行权限的实时更新，需要重新登录之后才能获取最新权限。
   ```
   
   6. 遇到的问题：
   
   ```python
      1.字典序列化时其中的数字会被变为数字；
   2.session权限不会更新；
      3.表结构根据功能的变化一直在变；
   ```
   
3. **上层应用开发调用的就是现成的接口；**

   ```python
   gensim,jieba,智能ai接口
   ```

4. ##### django中的多个数据库连接

   配置

   ```
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.sqlite3',
           'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
       },
       'db2': {
           'ENGINE': 'django.db.backends.sqlite3',
           'NAME': os.path.join(BASE_DIR, 'db2.sqlite3'),
       },
   }
   ```

   迁移其他的数据库

   python manage.py migrate --database db2

   读写分离

   手动

   ```
   models.Student.objects.using('db2').all()
   
   obj = models.Student.objects.using('db2').get(name='zhazha')
   obj.name = 'star'
   obj.save(using='default')
   ```

   自动

   settings配置:

   ```python
   DATABASE_ROUTERS = ['myrouter.Router']   # 在myrouter.py文件中写入Router类
   ```

   ```
   class Router:
       """
       读写分离
       """
       def db_for_write(self, model, **kwargs):
           return 'db2'
   
       def db_for_read(self, model, **kwargs):
           return 'default'
   ```

   一主多从

   ```
   class Router:
       """
       一主多从
       """
   
       def db_for_write(self, model, **kwargs):
           return 'db1'
   
       def db_for_read(self, model, **kwargs):
           return random.choices['db2', 'db3', 'db4']
   ```

   分库分表

   ```Python
   class Router:
       """
       分库分表
   
       app01  model   db1
       app02  model   db2
       """
   
       def db_for_write(self, model, **kwargs):
           app_name = model._meta.app_label
           if app_name == 'app01':
               return 'db1'
           elif app_name == 'app02':
               return 'db2'
   
       def db_for_read(self, model, **kwargs):
           app_name = model._meta.app_label
           if app_name == 'app01':
               return 'db1'
           elif app_name == 'app02':
               return 'db2'
   ```

### 11.算法与数据结构

 https://www.cnblogs.com/bigox/category/1538274.html 

- 三个其他面试题，参考：<https://www.cnblogs.com/wupeiqi/p/11604077.html>
  - python代码实现链表
  - 链表逆转
  - 两个队列实现一个栈







