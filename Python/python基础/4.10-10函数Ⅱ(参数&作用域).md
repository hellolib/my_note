# 4.10-10函数Ⅱ(参数&作用域)

- 面试题知识小结:
  - py2与py3的区别
  - 逻辑运算()>not>and>or
  - 字符串翻转切片翻转
  - is与==区别
  - git相关
  - 数据类型判断
  - 操作系统:centos,redhat
  - 数据类型的操作方法
  - 深浅拷贝
  - 大文件(日志文件)读取
  - 一行写成99乘法表

## 1.参数

- 实际参数可以是任何值

- 函数没有返回值,默认返回None

- 函数内部执行时,遇到return就终止运行

- return可以返回任何数据类型的值,多个值时返回元组

  ```python
  # enconding: utf-8
  def test():
      return 1,2,3
  print(test())		#(1, 2, 3)
  ```

### 1.传参

- **传参**:调用函数并传递参数,实参与形参必须一一对应

- **位置传参**:严格按照位置先后顺序传参

- **关键字传参**:直接赋值传参,无先后顺序

- **混合传参**:位置参数与关键字参数混合使用,**位置参数一定在关键字参数之前**

  ```python
  def func(a1, a2):
  print(a1, a2)
  func(a2=99,a1=2)
  # 关键字传参数和位置传参可以混合使用（位置传入的参数 > 关键字参数在后 = 总参数个数）
  def func1(a1, a2, a3):
  print(a1, a2, a3)
  # func(1, 2, a3=9)
  # func(1, a2=2, a3=9)
  # func(a1=1, a2=2, a3=9)
  # func(a1=1, 2,3) # 错误
  ```

### 2.默认参数

- **默认参数:**在函数建立时定义好的参数.
- 默认参数可传可不传.不传参使用默认值,传递参数相当于重新对默认参数赋值.
- 默认参数尽量用不可变数据类型,慎用可变数据类型!可变数据类型慎用!有坑!

### 3.*参数    万能参数(打散)

- (*args)只接收位置参数

- 格式(*参数)可以接收多个参数,但是**只支持位置传参**

- 实参传递到形参时是以元组形式传递

- 传参时实参前加星(*实参),先把实参打散,再传参到形参

  ```python
  def func(*args):
  print(args)
  # func(1)
  # func(1,2)
  func(1,2) # args=(1, 2)
  func((11,22,33,44,55)) # args=((11,22,33,44,55),)
  func(*(11,22,33,44,55)) # args=(11,22,33,44,55)
  ```

### 4.**参数   万能参数

- **(kwargs)

- 只接收关键

- 字参数

- 实参传递到形参时是以字典形式传递{'k'=v}

- 传参时实参前加**,直接传递字典

  ```python
  def func(*args,**kwargs):
  print(args,kwargs)
  # func(1,2,3,4,5,k1=2,k5=9,k19=999)
  func(*[1,2,3],k1=2,k5=9,k19=999)
  func(*[1,2,3],**{'k1':1,'k2':3})
  func(111,222,*[1,2,3],k11='alex',**{'k1':1,'k2':3})
  ```

注意:一般*args与**kwargs一起使用,这是超级无敌万能参数

```
经典例题:
#    def func(*args,**kwargs):
#        print(args,kwargs)
#    # a. 执行 func(12,3,*[11,22]) ，输出什么？
#    # b. 执行 func(('alex','武沛齐',),name='eric')
'''a.(12,3,11,22) {}
b.(('alex','武沛齐'),) {'name':'eric'}'''
```



### 参数重点总结

1.常见形参模式:

```python
def func1(a1,a2):
pass
def func2(a1,a2=None):
pass
def func3(*args,**kwargs):
pass
```

2.位置参数永远在关键字参数之前!

## 2.作用域scope与函数嵌套

- 作用域就是作用范围，按照生效范围可以分为全局作用域和局部作用域。

- python
  + 一个py文件是一个全局作用域
  + 一个函数是一个作用域

- 作用域中查找数据规则:优先查找自己局域内数据,自己没有再去父级作用域查找,以此类推,**可以找到,可以修改,不能为父级作用域的变量重新赋值.**

- *global '全局,全球'强制更改**全局作用作用域** ,先global+变量,再对变量赋值*

- *nonlocal '外地'  强制更改**父级作用域变量 **,先nonlocal+变量,再对变量赋值*

  ```python
  # 示例一
  name = ["老男孩",'alex']
  def func():
      global name
      name = '我'
  func()
  print(name)
  # ############################## nonlocal
  name = "老男孩"
  def func():
      name = 'alex'
      def inner():
          nonlocal name # 找到上一级的name
          name = 999
      inner()
      print(name)
  func()
  print(name)
  ```

  

- **全局作用域:**全局作用域内的数据公用

  - 全局变量全部大写

- **局部作用域:**局部作用域可以使用全局作用域内的数据,但是全局作用域使用不了局部作用域的数据即

  - 局部变量正常变量定义

- 函数的作用域链：小范围作用域可以使用大范围的变量，但是反之不行，他是单向的。

- 函数内只可以调用全局作用域的函数

  ```python
  # x = 10
  # def func():
  #     x = 9
  #     print(x)
  #     def x1():
  #         x = 999
  #         print(x)
  #     print(x)
  #     x1()
  #
  # func()
  
  # x = 10
  # def func():
  #     x = 8
  #     print(x)
  #     def x1():
  #         x = 999
  #         print(x)
  #     x1()
  #     print(x)
  #
  # func()
  
  
  # x = 10
  # def func():
  #     x = 8
  #     print(x)
  #     def x1():
  #         print(x)
  #     x1()
  #     print(x)
  #
  # func()
  
  
  
  # x = 10
  # def func():
  #     x = 8
  #     print(x)
  #     def x1():
  #         print(x)
  #     x = 9
  #     x1()
  #     x = 10
  #     print(x)
  #
  # func()
  
  ```

## 总结

- 参数
  - 调用（执行）函数时，传参：位置参数 > 关键字参数
  - 定义函数：
    - def func(a)
    - def func(a,b=None)   # 对于默认值，如果是可变类型，----> 坑。 
    - def func(*args,**kwargs)
- 作用域
  - 函数为作用域
  - 自己 > 父级 > 父级 > 全局 【读/修改（可变）】
  - 重新赋值：
    - global 全局	
    - nonlocal   外层